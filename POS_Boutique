# -*- coding: utf-8 -*-
"""
Aplicación de Punto de Venta con PyQt6.
Versión conectada a la base de datos en la nube Firebase Firestore.
"""
import sys
import json
import os
import datetime
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

import firebase_admin
from firebase_admin import credentials, firestore

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QLineEdit, QStackedWidget, QFrame, QTableWidget,
    QTableWidgetItem, QHeaderView, QMessageBox, QDialog, QFormLayout,
    QDialogButtonBox, QDateEdit, QComboBox, QInputDialog, QTextEdit,
    QGridLayout, QCompleter, QCheckBox
)
from PyQt6.QtCore import pyqtSignal, Qt, QDate, QTimer
from PyQt6.QtGui import QDoubleValidator, QPixmap

from fpdf import FPDF

# Se mueve la importación aquí para verificarla después de iniciar la app
try:
    from barcode import Code128
    from barcode.writer import ImageWriter
except ImportError:
    pass


# --- Función de Ayuda para Rutas de Archivos ---
def resource_path(relative_path):
    """ Obtiene la ruta absoluta al recurso, funciona para desarrollo y para PyInstaller """
    try:
        # PyInstaller crea una carpeta temporal y guarda la ruta en _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        # Esta línea asegura que la ruta base sea siempre la del script
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, relative_path)


db = None


def setup_database():
    """
    Verifica y crea los documentos iniciales en Firestore si no existen.
    """
    try:
        # 1. Verificar/Crear configuración de la app
        config_ref = db.collection('config').document('app_config')
        if not config_ref.get().exists:
            default_config = {
                "last_ticket_number": 0,
                "appearance_mode": "Oscuro",
                "color_theme": "Azul"
            }
            config_ref.set(default_config)
            print("Documento de configuración inicial creado en Firebase.")

        # 2. Verificar/Crear usuario administrador principal
        admin_ref = db.collection('users').document('E001')
        if not admin_ref.get().exists:
            admin_user = {
                "password": "admin",
                "full_name": "Administrador Principal",
                "permissions": {
                    "can_sell": True,
                    "can_manage_inventory": True,
                    "can_view_history": True,
                    "can_process_returns": True,
                    "can_manage_users": True,
                    "can_view_settings": True,
                    "can_do_cash_count": True
                }
            }
            admin_ref.set(admin_user)
            print("Usuario administrador principal creado en Firebase.")
    except Exception as e:
        QMessageBox.critical(None, "Error de Inicialización",
                             f"No se pudo configurar la base de datos inicial en Firebase.\n\nError: {e}")


def get_next_employee_id():
    """
    Genera el siguiente ID de empleado (ej. E002, E003).
    """
    users_ref = db.collection('users')
    docs = users_ref.stream()
    max_id_num = 0
    for doc in docs:
        username = doc.id
        if username.startswith("E") and username[1:].isdigit():
            num = int(username[1:])
            if num > max_id_num:
                max_id_num = num
    return f"E{max_id_num + 1:03d}"


# --- Funciones de Tickets y Correo ---

def generate_ticket_text(sale_record):
    customer_name = sale_record.get("customer_name", "Público General")
    if not customer_name.strip():
        customer_name = "Público General"

    try:
        date_str = datetime.datetime.fromisoformat(sale_record.get('timestamp', '')).strftime('%Y-%m-%d %H:%M:%S')
    except (ValueError, TypeError):
        date_str = "Fecha inválida"

    header = (
        f"BOUTIQUE EL IMPULSO\n"
        f"----------------------------------------\n"
        f"Ticket N°: {sale_record.get('ticket_number', 'N/A')}\n"
        f"Fecha: {date_str}\n"
        f"Cliente: {customer_name}\n"
        f"Atendido por: {sale_record.get('user', 'N/A')}\n"
        f"----------------------------------------\n"
    )
    items_text = ""
    for item in sale_record.get('items', []):
        line = f"{item.get('quantity', 0)}x {item.get('name', 'Producto Desconocido')}"
        total_line = f"${item.get('price', 0.0) * item.get('quantity', 0):.2f}"
        items_text += f"{line:<30}{total_line:>10}\n"
            
    footer = (
        f"----------------------------------------\n"
        f"Metodo de Pago: {sale_record.get('payment_method', 'N/A')}\n"
        f"TOTAL: ${sale_record.get('total', 0.0):.2f}\n\n"
        f"¡Gracias por su compra!\n\n"
        f"Este ticket de compra NO ES UN\n"
        f"COMPROBANTE FISCAL.\n"
        f"Para devoluciones solamente se cuenta\n"
        f"con 7 días naturales a partir de la\n"
        f"fecha de compra.\n"
    )
    return header + items_text + footer

def generate_ticket_pdf(sale_record, filename="ticket.pdf"):
    pdf = FPDF()
    pdf.add_page()
    
    logo_path = resource_path("logo.jpg")
    if os.path.exists(logo_path):
        page_width = pdf.w - 2 * pdf.l_margin
        pdf.image(logo_path, x=(page_width / 2) + pdf.l_margin - 15, y=8, w=30)
        pdf.ln(30)

    pdf.set_font("Courier", size=10)
    ticket_text = generate_ticket_text(sale_record)
    ticket_text_encoded = ticket_text.encode('latin-1', 'replace').decode('latin-1')
    pdf.multi_cell(0, 5, txt=ticket_text_encoded, align='C')
    pdf.output(filename)

# --- INICIO DE LA MODIFICACIÓN ---
# La función ahora lee la configuración de correo desde Firebase.
def send_email_with_attachment(recipient_email, sale_record):
    try:
        # Obtener configuración de correo desde Firebase
        email_config_doc = db.collection('config').document('email_config').get()
        if not email_config_doc.exists or 'sender_email' not in email_config_doc.to_dict() or 'sender_password' not in email_config_doc.to_dict():
            QMessageBox.critical(None, "Configuración Requerida", 
                                 "La configuración de correo no se ha establecido.\n\n"
                                 "Vaya a 'Ajustes' para ingresar el correo y la contraseña de aplicación.")
            return

        email_config = email_config_doc.to_dict()
        sender_email = email_config.get('sender_email')
        sender_password = email_config.get('sender_password')

        if not sender_email or not sender_password:
            QMessageBox.critical(None, "Configuración Incompleta", "Faltan el correo o la contraseña en la configuración de 'Ajustes'.")
            return

        # Generar el PDF temporalmente
        pdf_filename = resource_path(f"temp_ticket_{sale_record['ticket_number']}.pdf")
        generate_ticket_pdf(sale_record, pdf_filename)

        # Crear el mensaje de correo
        msg = MIMEMultipart()
        msg['From'] = f"Boutique El Impulso <{sender_email}>"
        msg['To'] = recipient_email
        msg['Subject'] = f"Su Ticket de Compra - Boutique El Impulso (Ticket #{sale_record['ticket_number']})"
        body = "¡Hola!\n\nAdjunto encontrará su ticket de compra.\n\nGracias por su preferencia."
        msg.attach(MIMEText(body, 'plain'))

        # Adjuntar el PDF
        with open(pdf_filename, "rb") as attachment:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", f"attachment; filename=ticket_{sale_record['ticket_number']}.pdf")
        msg.attach(part)

        # Conectar al servidor SMTP y enviar
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(sender_email, sender_password)
        server.send_message(msg)
        server.quit()
        
        QMessageBox.information(None, "Éxito", f"Ticket enviado correctamente a {recipient_email}.")

    except smtplib.SMTPAuthenticationError:
        QMessageBox.critical(None, "Error de Autenticación", 
                             "El correo o la contraseña de aplicación son incorrectos. Verifique la configuración en 'Ajustes'.")
    except Exception as e:
        QMessageBox.critical(None, "Error de Envío", f"No se pudo enviar el correo. Error: {e}")
    finally:
        # Limpiar el archivo PDF temporal
        if 'pdf_filename' in locals() and os.path.exists(pdf_filename):
            os.remove(pdf_filename)
# --- FIN DE LA MODIFICACIÓN ---


def print_thermal_ticket(sale_record):
    ticket_text = generate_ticket_text(sale_record)
    try:
        QMessageBox.information(None, "Impresión Simulada", 
            "La función de impresión real está comentada.\n\n"
            f"DATOS A IMPRIMIR:\n{ticket_text}")
    except Exception as e:
        QMessageBox.critical(None, "Error de Impresión", 
            f"No se pudo conectar con la impresora térmica.\n\nError: {e}")

def open_cash_drawer():
    try:
        QMessageBox.information(None, "Simulación", "Comando para abrir el cajón de dinero enviado.")
    except Exception as e:
        QMessageBox.critical(None, "Error de Cajón", 
            f"No se pudo enviar el comando al cajón de dinero.\nError: {e}")


def generate_cash_count_pdf(summary_text, user_id):
    folder = resource_path("cortes")
    os.makedirs(folder, exist_ok=True)
    filename = os.path.join(folder, f"corte_{datetime.date.today()}.pdf")
    
    pdf = FPDF()
    pdf.add_page()

    logo_path = resource_path("logo.jpg")
    if os.path.exists(logo_path):
        page_width = pdf.w - 2 * pdf.l_margin
        pdf.image(logo_path, x=(page_width / 2) + pdf.l_margin - 15, y=8, w=30)
        pdf.ln(30)

    pdf.set_font("Courier", 'B', 16)
    pdf.cell(0, 10, "Corte de Caja", 0, 1, 'C')
    pdf.ln(5)
    
    header = (
        f"Fecha: {datetime.date.today()}\n"
        f"Hora: {datetime.datetime.now().strftime('%H:%M:%S')}\n"
        f"Usuario: {user_id}\n"
    )
    pdf.set_font("Courier", size=10)
    pdf.multi_cell(0, 5, txt=header, align='C')
    pdf.ln(5)
    pdf.multi_cell(0, 5, txt=summary_text.encode('latin-1', 'replace').decode('latin-1'), align='C')
    
    pdf.output(filename)
    return filename

# --- Diálogos Personalizados ---
class ProductDialog(QDialog):
    def __init__(self, parent=None, product_data=None):
        super().__init__(parent)
        self.setWindowTitle("Detalles del Producto")
        self.setMinimumWidth(400)

        self.layout = QFormLayout(self)
        self.sku_input = QLineEdit(self)
        self.name_input = QLineEdit(self)
        self.price_input = QLineEdit("0.00")
        self.quantity_input = QLineEdit("0")
        
        price_grid = QGridLayout()
        self.price_5_input = QLineEdit("0.00")
        self.price_12_input = QLineEdit("0.00")
        self.price_50_input = QLineEdit("0.00")
        self.price_100_input = QLineEdit("0.00")
        self.price_300_input = QLineEdit("0.00")
        self.price_500_input = QLineEdit("0.00")

        price_grid.addWidget(QLabel("P. 5:"), 0, 0)
        price_grid.addWidget(self.price_5_input, 0, 1)
        price_grid.addWidget(QLabel("P. 12:"), 0, 2)
        price_grid.addWidget(self.price_12_input, 0, 3)
        price_grid.addWidget(QLabel("P. 50:"), 1, 0)
        price_grid.addWidget(self.price_50_input, 1, 1)
        price_grid.addWidget(QLabel("P. 100:"), 1, 2)
        price_grid.addWidget(self.price_100_input, 1, 3)
        price_grid.addWidget(QLabel("P. 300:"), 2, 0)
        price_grid.addWidget(self.price_300_input, 2, 1)
        price_grid.addWidget(QLabel("P. 500:"), 2, 2)
        price_grid.addWidget(self.price_500_input, 2, 3)

        self.layout.addRow("SKU:", self.sku_input)
        self.layout.addRow("Nombre:", self.name_input)
        self.layout.addRow("Precio Normal:", self.price_input)
        self.layout.addRow("Cantidad:", self.quantity_input)
        self.layout.addRow(QLabel("--- Precios de Mayoreo ---"))
        self.layout.addRow(price_grid)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.layout.addWidget(self.button_box)

        if product_data:
            self.sku_input.setText(product_data.get("sku", ""))
            self.sku_input.setReadOnly(True)
            self.name_input.setText(product_data.get("name", ""))
            self.price_input.setText(str(product_data.get("price", "0.0")))
            self.quantity_input.setText(str(product_data.get("quantity", "0")))
            self.price_5_input.setText(str(product_data.get("price_5", "0.0")))
            self.price_12_input.setText(str(product_data.get("price_12", "0.0")))
            self.price_50_input.setText(str(product_data.get("price_50", "0.0")))
            self.price_100_input.setText(str(product_data.get("price_100", "0.0")))
            self.price_300_input.setText(str(product_data.get("price_300", "0.0")))
            self.price_500_input.setText(str(product_data.get("price_500", "0.0")))

    def get_data(self):
        return {
            "sku": self.sku_input.text().upper(),
            "name": self.name_input.text(),
            "price": self.price_input.text(),
            "quantity": self.quantity_input.text(),
            "price_5": self.price_5_input.text(),
            "price_12": self.price_12_input.text(),
            "price_50": self.price_50_input.text(),
            "price_100": self.price_100_input.text(),
            "price_300": self.price_300_input.text(),
            "price_500": self.price_500_input.text(),
        }

class UserPermissionsDialog(QDialog):
    def __init__(self, parent=None, user_data=None, is_new_user=False):
        super().__init__(parent)
        self.setWindowTitle("Detalles y Permisos de Usuario")
        self.setMinimumWidth(450)
        
        self.main_layout = QVBoxLayout(self)
        form_layout = QFormLayout()
        
        self.full_name_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)

        form_layout.addRow("Nombre Completo:", self.full_name_input)
        form_layout.addRow("Contraseña:", self.password_input)
        
        self.main_layout.addLayout(form_layout)

        if is_new_user:
            self.template_combo = QComboBox()
            self.template_combo.addItems(["Vendedor", "Administrador"])
            self.template_combo.currentTextChanged.connect(self.apply_template)
            form_layout.addRow("Plantilla de Permisos:", self.template_combo)
        
        permissions_container = QWidget()
        permissions_layout = QGridLayout(permissions_container)
        self.permission_checkboxes = {}
        
        permissions_map = [
            ("can_sell", "Realizar Ventas"), ("can_manage_inventory", "Admin. Inventario"),
            ("can_view_history", "Ver Historial"), ("can_process_returns", "Procesar Devoluciones"),
            ("can_manage_users", "Gestionar Usuarios"), ("can_view_settings", "Ver Ajustes"),
            ("can_do_cash_count", "Realizar Corte de Caja")
        ]
        
        row, col = 0, 0
        for key, text in permissions_map:
            checkbox = QCheckBox(text)
            self.permission_checkboxes[key] = checkbox
            permissions_layout.addWidget(checkbox, row, col)
            col += 1
            if col > 1:
                col = 0
                row += 1
        
        self.main_layout.addWidget(QLabel("--- Permisos ---"))
        self.main_layout.addWidget(permissions_container)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.main_layout.addWidget(self.button_box)

        if user_data:
            self.full_name_input.setText(user_data.get("full_name", ""))
            self.password_input.setPlaceholderText("Dejar en blanco para no cambiar")
            permissions = user_data.get("permissions", {})
            for key, checkbox in self.permission_checkboxes.items():
                checkbox.setChecked(permissions.get(key, False))
        elif is_new_user:
            self.apply_template("Vendedor")
            
    def apply_template(self, template_name):
        perms = {
            "can_sell": True, "can_manage_inventory": False, 
            "can_view_history": False, "can_process_returns": False, 
            "can_manage_users": False, "can_view_settings": False, 
            "can_do_cash_count": True
        }
        if template_name == "Administrador":
            perms = {key: True for key in perms}
        
        for key, checkbox in self.permission_checkboxes.items():
            checkbox.setChecked(perms.get(key, False))

    def get_data(self):
        permissions = {key: checkbox.isChecked() for key, checkbox in self.permission_checkboxes.items()}
        return {
            "full_name": self.full_name_input.text(),
            "password": self.password_input.text(),
            "permissions": permissions
        }

class PaymentDialog(QDialog):
    def __init__(self, total, parent=None):
        super().__init__(parent)
        self.total = total
        self.setWindowTitle("Procesar Pago")
        self.setMinimumWidth(350)
        self.layout = QVBoxLayout(self)
        total_label = QLabel(f"Total a Pagar: ${self.total:.2f}")
        total_label.setStyleSheet("font-size: 20px; font-weight: bold;")
        self.layout.addWidget(total_label)
        self.payment_method_combo = QComboBox(self)
        self.payment_method_combo.addItems(["Efectivo", "Tarjeta Bancaria", "Transferencia Bancaria"])
        self.layout.addWidget(self.payment_method_combo)
        self.stacked_widget = QStackedWidget(self)
        self.setup_cash_view()
        self.setup_folio_view()
        self.layout.addWidget(self.stacked_widget)
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.layout.addWidget(self.button_box)
        self.payment_method_combo.currentIndexChanged.connect(self.stacked_widget.setCurrentIndex)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
    def setup_cash_view(self):
        cash_widget = QWidget()
        cash_layout = QFormLayout(cash_widget)
        self.amount_received_input = QLineEdit(self)
        self.amount_received_input.setValidator(QDoubleValidator(0.0, 1000000.0, 2))
        self.change_label = QLabel("$0.00")
        cash_layout.addRow("Monto Recibido:", self.amount_received_input)
        cash_layout.addRow("Cambio a devolver:", self.change_label)
        self.amount_received_input.textChanged.connect(self.calculate_change)
        self.amount_received_input.returnPressed.connect(self.validate_and_accept)
        self.stacked_widget.addWidget(cash_widget)
    def setup_folio_view(self):
        folio_widget = QWidget()
        folio_layout = QFormLayout(folio_widget)
        self.folio_input = QLineEdit(self)
        folio_layout.addRow("Número de Folio:", self.folio_input)
        self.folio_input.returnPressed.connect(self.validate_and_accept)
        self.stacked_widget.addWidget(folio_widget)
    def calculate_change(self):
        try:
            received = float(self.amount_received_input.text())
            change = received - self.total
            self.change_label.setText(f"${change:.2f}")
        except ValueError:
            self.change_label.setText("$0.00")
    def validate_and_accept(self):
        method = self.payment_method_combo.currentText()
        if method == "Efectivo":
            try:
                received = float(self.amount_received_input.text())
                if received < self.total:
                    QMessageBox.warning(self, "Monto insuficiente", "El monto recibido no puede ser menor que el total.")
                    return
            except ValueError:
                QMessageBox.warning(self, "Monto inválido", "Por favor, ingrese un monto recibido válido.")
                return
        else:
            if not self.folio_input.text().strip():
                QMessageBox.warning(self, "Folio requerido", "Por favor, ingrese el número de folio de la transacción.")
                return
        self.accept()
    def get_data(self):
        method = self.payment_method_combo.currentText()
        details = {}
        if method == "Efectivo":
            try:
                received = float(self.amount_received_input.text())
            except ValueError:
                received = 0.0
            details = {"received": received, "change": received - self.total}
        else:
            details = {"folio": self.folio_input.text().strip()}
        return {"method": method, "details": details}

class PostSaleDialog(QDialog):
    def __init__(self, sale_record, parent=None):
        super().__init__(parent)
        self.sale_record = sale_record
        self.setWindowTitle("Acciones de Venta")
        
        layout = QVBoxLayout(self)
        label = QLabel(f"Venta #{sale_record['ticket_number']} finalizada con éxito.")
        label.setStyleSheet("font-size: 16px; margin-bottom: 10px;")
        
        print_button = QPushButton("Imprimir Ticket Térmico")
        email_button = QPushButton("Enviar por Correo")
        close_button = QPushButton("Finalizar")
        
        layout.addWidget(label)
        layout.addWidget(print_button)
        layout.addWidget(email_button)
        layout.addWidget(close_button)
        
        print_button.clicked.connect(self.print_ticket)
        email_button.clicked.connect(self.email_ticket)
        close_button.clicked.connect(self.accept)

    def print_ticket(self):
        print_thermal_ticket(self.sale_record)
        self.accept()

    def email_ticket(self):
        email, ok = QInputDialog.getText(self, "Enviar Ticket", "Correo electrónico del cliente:")
        if ok and email:
            send_email_with_attachment(email, self.sale_record)
            self.accept()

# --- Vistas o Pantallas de la Aplicación ---
class LoginScreen(QWidget):
    login_successful = pyqtSignal(dict, str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()

    def init_ui(self):
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        left_panel = QFrame(self)
        left_panel.setObjectName("leftPanel")
        left_panel.setMaximumWidth(350)
        
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(40, 40, 40, 40)

        logo_label = QLabel(self)
        logo_path = resource_path("logo.jpg")
        if os.path.exists(logo_path):
            pixmap = QPixmap(logo_path)
            logo_label.setPixmap(pixmap.scaled(120, 120, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation))
            logo_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        else:
            logo_label.setText("BOUTIQUE EL IMPULSO")
            logo_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            logo_label.setStyleSheet("font-size: 18px; font-weight: bold;")
        
        user_label = QLabel("Usuario (E### o admin):")
        user_label.setObjectName("loginFormLabel")
        self.username_input = QLineEdit(self)
        self.username_input.setPlaceholderText("E001 / admin")
        
        pass_label = QLabel("Contraseña:")
        pass_label.setObjectName("loginFormLabel")
        self.password_input = QLineEdit(self)
        self.password_input.setPlaceholderText("Contraseña")
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)

        self.login_button = QPushButton("INICIAR SESIÓN")
        self.login_button.setObjectName("loginButton")
        self.recover_button = QPushButton("RECUPERAR CONTRASEÑA")
        self.recover_button.setObjectName("recoverButton")
        
        left_layout.addWidget(logo_label, alignment=Qt.AlignmentFlag.AlignCenter)
        left_layout.addSpacing(30)
        left_layout.addWidget(user_label)
        left_layout.addWidget(self.username_input)
        left_layout.addSpacing(10)
        left_layout.addWidget(pass_label)
        left_layout.addWidget(self.password_input)
        left_layout.addSpacing(20)
        left_layout.addWidget(self.login_button)
        left_layout.addWidget(self.recover_button)
        left_layout.addStretch()

        right_panel = QFrame(self)
        right_panel.setObjectName("rightPanel")
        
        right_layout = QVBoxLayout(right_panel)
        right_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        greeting_label = QLabel(f"¡{self.get_dynamic_greeting()}!\nBienvenido(a)", self)
        greeting_label.setObjectName("greetingLabel")
        greeting_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        footer_label = QLabel("SISTEMA PUNTO DE VENTA BOUTIQUE EL IMPULSO", self)
        footer_label.setObjectName("footerLabel")

        right_layout.addStretch(1)
        right_layout.addWidget(greeting_label)
        right_layout.addStretch(1)
        right_layout.addWidget(footer_label, alignment=Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignBottom)

        main_layout.addWidget(left_panel)
        main_layout.addWidget(right_panel, 1)

        self.username_input.returnPressed.connect(self.password_input.setFocus)
        self.password_input.returnPressed.connect(self.check_login)
        self.login_button.clicked.connect(self.check_login)
        self.recover_button.clicked.connect(self.recover_password)

        bg_path = resource_path("background.png")
        if os.path.exists(bg_path):
            bg_path_stylesheet = bg_path.replace("\\", "/") 
            right_panel.setStyleSheet(f"QFrame#rightPanel {{ border-image: url('{bg_path_stylesheet}') 0 0 0 0 stretch stretch; border: none; }}")

    def get_dynamic_greeting(self):
        h = datetime.datetime.now().hour
        if 5 <= h < 12: return "Buen día"
        elif 12 <= h < 19: return "Buena tarde"
        else: return "Buena noche"

    def check_login(self):
        username = self.username_input.text().upper().strip()
        password = self.password_input.text()
        
        user_id_to_check = "E001" if username == "ADMIN" else username
        
        try:
            user_doc = db.collection('users').document(user_id_to_check).get()
            if user_doc.exists:
                user_data = user_doc.to_dict()
                if user_data.get("password") == password:
                    permissions = user_data.get("permissions", {})
                    # Forzar todos los permisos para el administrador principal
                    if user_id_to_check == "E001":
                        permissions = {k: True for k, v in permissions.items()}
                    self.login_successful.emit(permissions, user_id_to_check)
                else:
                    QMessageBox.warning(self, "Error de Autenticación", "Contraseña incorrecta.")
            else:
                QMessageBox.warning(self, "Error de Autenticación", "Usuario no encontrado.")
        except Exception as e:
            QMessageBox.critical(self, "Error de Conexión", f"No se pudo verificar el usuario: {e}")

    def recover_password(self):
        username, ok = QInputDialog.getText(self, "Recuperar Contraseña", "Ingrese su número de empleado (ej. E002):")
        
        if ok and username:
            username = username.strip().upper()
            try:
                user_doc = db.collection('users').document(username).get()
                if user_doc.exists:
                    password = user_doc.to_dict().get("password", "No encontrada")
                    QMessageBox.information(self, "Contraseña Recuperada", f"La contraseña para '{username}' es: {password}")
                else:
                    QMessageBox.warning(self, "Usuario no Encontrado", f"El usuario '{username}' no fue encontrado.")
            except Exception as e:
                QMessageBox.critical(self, "Error de Conexión", f"No se pudo recuperar la contraseña: {e}")

class InventoryScreen(QWidget):
    inventory_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()
        self.load_inventory()

    def init_ui(self):
        layout = QVBoxLayout(self)
        title_label = QLabel("Gestión de Inventario", self)
        title_label.setStyleSheet("font-size: 18px; font-weight: bold;")
        layout.addWidget(title_label)

        self.table = QTableWidget(self)
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(["SKU", "Nombre", "P. Normal", "P. 5 (Mayoreo)", "Cantidad"])
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        for i in range(2, 5):
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)
        layout.addWidget(self.table)
        
        button_layout = QHBoxLayout()
        add_button = QPushButton("Añadir Producto")
        remove_button = QPushButton("Eliminar Producto")
        pdf_button = QPushButton("Guardar como PDF")
        barcode_button = QPushButton("Generar Códigos de Barras")
        refresh_button = QPushButton("Refrescar Lista")
        
        button_layout.addWidget(add_button)
        button_layout.addWidget(remove_button)
        button_layout.addWidget(pdf_button)
        button_layout.addWidget(barcode_button)
        button_layout.addStretch()
        button_layout.addWidget(refresh_button)
        layout.addLayout(button_layout)
        
        refresh_button.clicked.connect(self.load_inventory)
        add_button.clicked.connect(self.add_product)
        remove_button.clicked.connect(self.remove_product)
        pdf_button.clicked.connect(self.save_inventory_pdf)
        barcode_button.clicked.connect(self.open_barcode_generator)
        self.table.cellDoubleClicked.connect(self.edit_product)

    def load_inventory(self):
        try:
            inventory_docs = db.collection('inventory').stream()
            inventory_data = {doc.id: doc.to_dict() for doc in inventory_docs}
            self.table.setRowCount(0)
            self.table.setRowCount(len(inventory_data))
            for row, (sku, data) in enumerate(inventory_data.items()):
                self.table.setItem(row, 0, QTableWidgetItem(sku))
                self.table.setItem(row, 1, QTableWidgetItem(data.get("name", "N/A")))
                self.table.setItem(row, 2, QTableWidgetItem(f"${data.get('price', 0.0):.2f}"))
                self.table.setItem(row, 3, QTableWidgetItem(f"${data.get('price_5', 0.0):.2f}"))
                self.table.setItem(row, 4, QTableWidgetItem(str(data.get("quantity", 0))))
        except Exception as e:
            QMessageBox.critical(self, "Error de Carga", f"No se pudo cargar el inventario: {e}")

    def add_product(self):
        dialog = ProductDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.save_product_data(dialog.get_data())

    def edit_product(self, row, column):
        sku = self.table.item(row, 0).text()
        try:
            product_doc = db.collection('inventory').document(sku).get()
            if product_doc.exists:
                product_data = product_doc.to_dict()
                product_data["sku"] = sku
                dialog = ProductDialog(self, product_data=product_data)
                if dialog.exec() == QDialog.DialogCode.Accepted:
                    self.save_product_data(dialog.get_data(), is_edit=True)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"No se pudo obtener el producto: {e}")

    def save_product_data(self, data, is_edit=False):
        if not data["sku"] or not data["name"]:
            QMessageBox.warning(self, "Datos incompletos", "El SKU y el Nombre son obligatorios.")
            return

        try:
            product_record = {
                "name": data["name"],
                "price": float(data["price"]), "quantity": int(data["quantity"]),
                "price_5": float(data["price_5"]), "price_12": float(data["price_12"]),
                "price_50": float(data["price_50"]), "price_100": float(data["price_100"]),
                "price_300": float(data["price_300"]), "price_500": float(data["price_500"]),
            }
            sku = data["sku"]
            
            inventory_ref = db.collection('inventory')
            if not is_edit and inventory_ref.document(sku).get().exists:
                QMessageBox.warning(self, "SKU duplicado", "El SKU ya existe.")
                return

            inventory_ref.document(sku).set(product_record)
            self.load_inventory()
            self.inventory_changed.emit()

        except ValueError:
            QMessageBox.warning(self, "Error de Formato", "Todos los campos de precio y cantidad deben ser números válidos.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Ocurrió un error inesperado: {e}")

    def remove_product(self):
        selected_rows = self.table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self, "Sin Selección", "Por favor, seleccione un producto para eliminar.")
            return

        selected_row = selected_rows[0].row()
        sku = self.table.item(selected_row, 0).text()
        name = self.table.item(selected_row, 1).text()
        
        reply = QMessageBox.question(self, "Confirmar eliminación",
                                     f"¿Está seguro de que desea eliminar '{name}' (SKU: {sku})?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            try:
                db.collection('inventory').document(sku).delete()
                self.load_inventory()
                self.inventory_changed.emit()
                QMessageBox.information(self, "Éxito", f"Producto '{name}' eliminado.")
            except Exception as e:
                QMessageBox.critical(self, "Error de Base de Datos", f"No se pudo eliminar el producto: {e}")

    def save_inventory_pdf(self):
        try:
            inventory_docs = db.collection('inventory').stream()
            inventory = {doc.id: doc.to_dict() for doc in inventory_docs}
            if not inventory:
                QMessageBox.information(self, "Inventario Vacío", "No hay productos para generar un reporte.")
                return
        except Exception as e:
            QMessageBox.critical(self, "Error de Conexión", f"No se pudo acceder a la base de datos: {e}")
            return
            
        folder = resource_path("reportes")
        os.makedirs(folder, exist_ok=True)
        filename = os.path.join(folder, f"inventario_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf")

        try:
            pdf = FPDF(orientation='L', unit='mm', format='A4')
            pdf.add_page()
            
            logo_path = resource_path("logo.jpg")
            if os.path.exists(logo_path):
                page_width = pdf.w - 2 * pdf.l_margin
                pdf.image(logo_path, x=(page_width / 2) + pdf.l_margin - 15, y=8, w=30)
                pdf.ln(30)

            pdf.set_font("Courier", 'B', 16)
            pdf.cell(0, 10, "Reporte de Inventario", border=0, ln=1, align='C')
            pdf.ln(5)
            
            pdf.set_font("Courier", 'B', 8)
            col_widths = [25, 60, 20, 20, 20, 20, 20, 20, 20]
            headers = ["SKU", "Nombre", "P. Normal", "P. 5", "P. 12", "P. 50", "P. 100", "P. 300/500", "Cant."]
            for i, header in enumerate(headers):
                pdf.cell(col_widths[i], 8, header, border=1, align='C')
            pdf.ln()

            pdf.set_font("Courier", '', 8)
            for sku, data in sorted(inventory.items()):
                pdf.cell(col_widths[0], 6, sku, 1)
                safe_name = data.get('name', '').encode('latin-1', 'replace').decode('latin-1')
                pdf.cell(col_widths[1], 6, safe_name, 1)
                pdf.cell(col_widths[2], 6, f"${data.get('price', 0.0):.2f}", 1, align='R')
                pdf.cell(col_widths[3], 6, f"${data.get('price_5', 0.0):.2f}", 1, align='R')
                pdf.cell(col_widths[4], 6, f"${data.get('price_12', 0.0):.2f}", 1, align='R')
                pdf.cell(col_widths[5], 6, f"${data.get('price_50', 0.0):.2f}", 1, align='R')
                pdf.cell(col_widths[6], 6, f"${data.get('price_100', 0.0):.2f}", 1, align='R')
                pdf.cell(col_widths[7], 6, f"${data.get('price_300', 0.0):.2f}/${data.get('price_500', 0.0):.2f}", 1, align='R')
                pdf.cell(col_widths[8], 6, str(data.get("quantity", 0)), 1, align='C')
                pdf.ln()

            pdf.output(filename)
            QMessageBox.information(self, "Éxito", f"Reporte de inventario guardado como:\n{filename}")
        except Exception as e:
            QMessageBox.critical(self, "Error al generar PDF", f"No se pudo crear el archivo PDF.\nError: {e}")

    def open_barcode_generator(self):
        dialog = BarcodeGeneratorDialog(self)
        dialog.exec()

class SalesScreen(QWidget):
    sale_finalized = pyqtSignal()
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_sale_items = []
        self.current_user_id = None
        self.init_ui()
    def set_current_user(self, user_id):
        self.current_user_id = user_id
    def init_ui(self):
        layout = QHBoxLayout(self)
        left_panel = QFrame(self)
        left_panel.setFrameShape(QFrame.Shape.StyledPanel)
        left_panel.setMaximumWidth(400)
        left_layout = QVBoxLayout(left_panel)
        
        customer_label = QLabel("Nombre del Cliente (Opcional):")
        self.customer_name_input = QLineEdit(self)
        self.customer_name_input.setPlaceholderText("Público General")
        
        search_label = QLabel("Buscar Producto (SKU o Nombre):")
        self.product_search_input = QLineEdit(self)
        self.product_search_input.setPlaceholderText("Escanear o buscar y presionar Enter")
        
        left_layout.addWidget(customer_label)
        left_layout.addWidget(self.customer_name_input)
        left_layout.addSpacing(20)
        left_layout.addWidget(search_label)
        left_layout.addWidget(self.product_search_input)
        left_layout.addStretch()

        right_panel = QFrame(self)
        right_panel.setFrameShape(QFrame.Shape.StyledPanel)
        right_layout = QVBoxLayout(right_panel)
        cart_label = QLabel("Carrito de Compras")
        cart_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        self.cart_table = QTableWidget(self)
        self.cart_table.setColumnCount(4)
        self.cart_table.setHorizontalHeaderLabels(["Nombre", "Cantidad", "Precio Unitario", "Total"])
        self.cart_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.cart_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.cart_table.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)

        cart_actions_layout = QHBoxLayout()
        modify_qty_button = QPushButton("Modificar Cantidad")
        remove_item_button = QPushButton("Eliminar Producto")
        cart_actions_layout.addWidget(modify_qty_button)
        cart_actions_layout.addWidget(remove_item_button)
        cart_actions_layout.addStretch()

        total_layout = QHBoxLayout()
        self.subtotal_label = QLabel("Subtotal: $0.00")
        self.subtotal_label.setStyleSheet("font-size: 18px; font-weight: bold;")
        pay_button = QPushButton("Pagar")
        pay_button.setStyleSheet("font-size: 18px; padding: 10px;")
        total_layout.addWidget(self.subtotal_label)
        total_layout.addStretch()
        total_layout.addWidget(pay_button)
        
        right_layout.addWidget(cart_label)
        right_layout.addWidget(self.cart_table)
        right_layout.addLayout(cart_actions_layout)
        right_layout.addLayout(total_layout)
        
        layout.addWidget(left_panel)
        layout.addWidget(right_panel, stretch=1)
        
        self.product_search_input.returnPressed.connect(self.add_product_to_cart)
        pay_button.clicked.connect(self.process_payment)
        modify_qty_button.clicked.connect(self.modify_quantity)
        remove_item_button.clicked.connect(self.remove_item)
        self.cart_table.cellDoubleClicked.connect(self.modify_quantity_from_cell)

    def setup_completer(self):
        try:
            inventory_docs = db.collection('inventory').stream()
            name_list = [f"{doc.to_dict()['name']} [{doc.id}]" for doc in inventory_docs]
            self.completer = QCompleter(name_list, self)
            self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
            self.completer.setFilterMode(Qt.MatchFlag.MatchContains)
            self.product_search_input.setCompleter(self.completer)
        except Exception as e:
            print(f"No se pudo crear el autocompletado: {e}")

    def modify_quantity_from_cell(self, row, column):
        self.modify_quantity()

    def get_price_for_quantity(self, product_info, quantity):
        tiers = [(500, "price_500"), (300, "price_300"), (100, "price_100"), 
                 (50, "price_50"), (12, "price_12"), (5, "price_5")]
        
        for threshold, key in tiers:
            price = product_info.get(key)
            if price is not None and quantity >= threshold:
                return float(price)
        
        return float(product_info.get("price", 0.0))

    def add_product_to_cart(self):
        search_term = self.product_search_input.text().strip()
        if not search_term: return

        sku_to_add = None
        product_info = None

        if '[' in search_term and ']' in search_term:
            try: sku_to_add = search_term.split('[')[-1].split(']')[0].upper()
            except IndexError: pass
        else:
            sku_to_add = search_term.upper()

        try:
            if sku_to_add:
                doc = db.collection('inventory').document(sku_to_add).get()
                if doc.exists: product_info = doc.to_dict()

            if not product_info:
                inventory_ref = db.collection('inventory')
                query = inventory_ref.where('name', '==', search_term).limit(1)
                docs = query.stream()
                for doc in docs:
                    product_info = doc.to_dict()
                    sku_to_add = doc.id
                    break
            
            if not product_info:
                QMessageBox.warning(self, "No encontrado", f"No se encontró un producto con el SKU o nombre '{search_term}'.")
                return

            stock_available = product_info.get("quantity", 0)
            existing_item = next((item for item in self.current_sale_items if item["sku"] == sku_to_add), None)
            
            current_qty_in_cart = existing_item["quantity"] if existing_item else 0
            
            if current_qty_in_cart >= stock_available:
                QMessageBox.warning(self, "Stock Insuficiente", f"No hay más stock disponible para '{product_info['name']}'.")
                return

            if existing_item:
                existing_item["quantity"] += 1
            else:
                self.current_sale_items.append({"sku": sku_to_add, "name": product_info["name"], "quantity": 1})
            
            self.update_cart_display()
            self.product_search_input.clear()

        except Exception as e:
            QMessageBox.critical(self, "Error de Base de Datos", f"No se pudo buscar el producto: {e}")

    def update_cart_display(self):
        self.cart_table.setRowCount(len(self.current_sale_items))
        subtotal = 0
        try:
            for row, item in enumerate(self.current_sale_items):
                product_doc = db.collection('inventory').document(item["sku"]).get()
                if not product_doc.exists: continue
                
                product_info = product_doc.to_dict()
                effective_price = self.get_price_for_quantity(product_info, item["quantity"])
                item["price"] = effective_price
                
                total_item_price = effective_price * item["quantity"]
                subtotal += total_item_price
                
                self.cart_table.setItem(row, 0, QTableWidgetItem(item["name"]))
                self.cart_table.setItem(row, 1, QTableWidgetItem(str(item["quantity"])))
                self.cart_table.setItem(row, 2, QTableWidgetItem(f"${effective_price:.2f}"))
                self.cart_table.setItem(row, 3, QTableWidgetItem(f"${total_item_price:.2f}"))
            
            self.subtotal_label.setText(f"Subtotal: ${subtotal:.2f}")
        except Exception as e:
            QMessageBox.critical(self, "Error de Base de Datos", f"No se pudo actualizar el carrito: {e}")
    
    def modify_quantity(self):
        selected_rows = self.cart_table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self, "Sin Selección", "Por favor, seleccione un producto del carrito para modificar.")
            return
        
        selected_row = selected_rows[0].row()
        item = self.current_sale_items[selected_row]
        
        try:
            product_doc = db.collection('inventory').document(item["sku"]).get()
            stock_available = product_doc.to_dict().get("quantity", 0)

            new_quantity, ok = QInputDialog.getInt(
                self, "Modificar Cantidad", 
                f"Ingrese la nueva cantidad para '{item['name']}'\n(Stock disponible: {stock_available})",
                value=item["quantity"], min=1, max=stock_available
            )

            if ok:
                self.current_sale_items[selected_row]["quantity"] = new_quantity
                self.update_cart_display()
        except Exception as e:
            QMessageBox.critical(self, "Error de Base de Datos", f"No se pudo obtener el stock: {e}")

    def remove_item(self):
        selected_rows = self.cart_table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self, "Sin Selección", "Por favor, seleccione un producto del carrito para eliminar.")
            return

        selected_row = selected_rows[0].row()
        item = self.current_sale_items[selected_row]

        reply = QMessageBox.question(self, "Confirmar Eliminación",
                                     f"¿Está seguro de que desea eliminar '{item['name']}' del carrito?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            del self.current_sale_items[selected_row]
            self.update_cart_display()

    def process_payment(self):
        if not self.current_sale_items:
            QMessageBox.warning(self, "Carrito vacío", "Añada productos antes de pagar.")
            return
        
        total = sum(item['price'] * item['quantity'] for item in self.current_sale_items)
        payment_dialog = PaymentDialog(total, self)
        
        if payment_dialog.exec() == QDialog.DialogCode.Accepted:
            payment_data = payment_dialog.get_data()
            self.finalize_sale(total, payment_data)

    def finalize_sale(self, total, payment_data):
        try:
            config_ref = db.collection('config').document('app_config')
            config = config_ref.get().to_dict()
            
            new_ticket_number = config.get("last_ticket_number", 0) + 1
            
            sale_record = {
                "ticket_number": new_ticket_number,
                "timestamp": datetime.datetime.now().isoformat(),
                "user": self.current_user_id,
                "customer_name": self.customer_name_input.text(),
                "items": self.current_sale_items,
                "total": total,
                "payment_method": payment_data["method"],
                "payment_details": payment_data["details"],
                "status": "COMPLETADA"
            }
            db.collection('sales').add(sale_record)
            
            batch = db.batch()
            for item in self.current_sale_items:
                item_ref = db.collection('inventory').document(item["sku"])
                batch.update(item_ref, {'quantity': firestore.Increment(-item['quantity'])})
            batch.commit()
            
            config_ref.update({"last_ticket_number": new_ticket_number})
            
            if payment_data["method"] == "Efectivo":
                open_cash_drawer()

            post_sale_dialog = PostSaleDialog(sale_record, self)
            post_sale_dialog.exec()

            self.current_sale_items = []
            self.update_cart_display()
            self.customer_name_input.clear()
            self.sale_finalized.emit()
        except Exception as e:
            QMessageBox.critical(self, "Error al Finalizar Venta", f"No se pudo completar la venta: {e}")

class UserManagementScreen(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()
        self.load_users()
    def init_ui(self):
        layout = QVBoxLayout(self)
        title = QLabel("Gestión de Usuarios", self)
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        self.table = QTableWidget(self)
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels(["EID", "Nombre Completo", "Rol"])
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        
        button_layout = QHBoxLayout()
        add_btn = QPushButton("Añadir Usuario")
        edit_perms_btn = QPushButton("Editar Permisos")
        del_btn = QPushButton("Eliminar Usuario")
        refresh_btn = QPushButton("Refrescar")
        button_layout.addWidget(add_btn)
        button_layout.addWidget(edit_perms_btn)
        button_layout.addWidget(del_btn)
        button_layout.addStretch()
        button_layout.addWidget(refresh_btn)
        
        layout.addWidget(title)
        layout.addWidget(self.table)
        layout.addLayout(button_layout)

        add_btn.clicked.connect(self.add_user)
        del_btn.clicked.connect(self.remove_user)
        edit_perms_btn.clicked.connect(self.edit_user_permissions)
        refresh_btn.clicked.connect(self.load_users)
        self.table.cellDoubleClicked.connect(self.edit_user_permissions_from_cell)

    def load_users(self):
        try:
            users_docs = db.collection('users').stream()
            users = {doc.id: doc.to_dict() for doc in users_docs}
            self.table.setRowCount(0)
            self.table.setRowCount(len(users))
            for row, (eid, data) in enumerate(users.items()):
                permissions = data.get("permissions", {})
                is_admin = all(permissions.values())
                is_seller = permissions.get("can_sell") and not any([permissions.get(k, False) for k in ["can_manage_inventory", "can_manage_users"]])
                
                if eid == "E001" or is_admin: role = "Administrador"
                elif is_seller: role = "Vendedor"
                else: role = "Personalizado"

                self.table.setItem(row, 0, QTableWidgetItem(eid))
                self.table.setItem(row, 1, QTableWidgetItem(data.get("full_name", "")))
                self.table.setItem(row, 2, QTableWidgetItem(role))
        except Exception as e:
            QMessageBox.critical(self, "Error de Carga", f"No se pudo cargar la lista de usuarios: {e}")
            
    def add_user(self):
        dialog = UserPermissionsDialog(self, is_new_user=True)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            data = dialog.get_data()
            if not all([data["full_name"], data["password"]]):
                QMessageBox.warning(self, "Datos incompletos", "El nombre y la contraseña son obligatorios.")
                return
            try:
                new_eid = get_next_employee_id()
                new_user_data = {"full_name": data["full_name"], "password": data["password"], "permissions": data["permissions"]}
                db.collection('users').document(new_eid).set(new_user_data)
                self.load_users()
            except Exception as e:
                QMessageBox.critical(self, "Error de Creación", f"No se pudo añadir el usuario: {e}")

    def edit_user_permissions_from_cell(self, row, column):
        self.edit_user_permissions()

    def edit_user_permissions(self):
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Sin selección", "Seleccione un usuario para editar.")
            return
        
        eid = self.table.item(row, 0).text()
        if eid == "E001":
            QMessageBox.warning(self, "Acción no Permitida", "No se pueden modificar los permisos del administrador principal.")
            return
        
        try:
            user_doc = db.collection('users').document(eid).get()
            if not user_doc.exists:
                QMessageBox.critical(self, "Error", "El usuario ya no existe.")
                self.load_users()
                return

            user_data = user_doc.to_dict()
            dialog = UserPermissionsDialog(self, user_data=user_data)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                new_data = dialog.get_data()
                update_payload = {"full_name": new_data["full_name"], "permissions": new_data["permissions"]}
                if new_data["password"]:
                    update_payload["password"] = new_data["password"]
                
                db.collection('users').document(eid).update(update_payload)
                self.load_users()
        except Exception as e:
            QMessageBox.critical(self, "Error de Edición", f"No se pudo editar el usuario: {e}")

    def remove_user(self):
        row = self.table.currentRow()
        if row < 0:
            QMessageBox.warning(self, "Sin selección", "Seleccione un usuario para eliminar.")
            return
        eid = self.table.item(row, 0).text()
        if eid == "E001":
            QMessageBox.critical(self, "Acción no permitida", "No se puede eliminar al administrador principal.")
            return

        reply = QMessageBox.question(self, "Confirmar", f"¿Seguro que desea eliminar al usuario {eid}?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            try:
                db.collection('users').document(eid).delete()
                self.load_users()
            except Exception as e:
                QMessageBox.critical(self, "Error de Eliminación", f"No se pudo eliminar el usuario: {e}")

class SalesHistoryScreen(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()
    def init_ui(self):
        layout = QVBoxLayout(self)
        title = QLabel("Historial de Ventas", self)
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        
        filter_layout = QHBoxLayout()
        self.start_date_edit = QDateEdit(self, calendarPopup=True)
        self.start_date_edit.setDate(QDate.currentDate())
        self.end_date_edit = QDateEdit(self, calendarPopup=True)
        self.end_date_edit.setDate(QDate.currentDate())
        
        today_btn = QPushButton("Ventas de Hoy")
        search_btn = QPushButton("Buscar por Rango")
        all_btn = QPushButton("Mostrar Todo")

        filter_layout.addWidget(QLabel("Desde:"))
        filter_layout.addWidget(self.start_date_edit)
        filter_layout.addWidget(QLabel("Hasta:"))
        filter_layout.addWidget(self.end_date_edit)
        filter_layout.addWidget(search_btn)
        filter_layout.addStretch()
        filter_layout.addWidget(today_btn)
        filter_layout.addWidget(all_btn)

        self.table = QTableWidget(self)
        self.table.setColumnCount(7)
        self.table.setHorizontalHeaderLabels(["Ticket #", "Fecha y Hora", "Cliente", "Usuario", "Método Pago", "Total", "Estado"])
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        
        layout.addWidget(title)
        layout.addLayout(filter_layout)
        layout.addWidget(self.table)

        today_btn.clicked.connect(self.load_today_sales)
        all_btn.clicked.connect(self.load_all_sales)
        search_btn.clicked.connect(self.load_date_range_sales)
        
        self.load_today_sales()

    def load_sales(self, query):
        try:
            sales_docs = query.stream()
            sales_list = [doc.to_dict() for doc in sales_docs]
            self.table.setRowCount(0)
            self.table.setRowCount(len(sales_list))

            # --- INICIO DE LA CORRECCIÓN ---
            # Se mejora la función de normalización para manejar fechas con y sin zona horaria.
            def get_sortable_timestamp(sale):
                ts = sale.get('timestamp')
                sortable_ts = None
                
                if isinstance(ts, str):
                    try:
                        # Convierte el texto a un objeto de fecha
                        sortable_ts = datetime.datetime.fromisoformat(ts)
                    except ValueError:
                        sortable_ts = datetime.datetime.min
                elif isinstance(ts, datetime.datetime):
                    # Si ya es un objeto de fecha, lo usa
                    sortable_ts = ts
                else:
                    # Si no hay fecha o es un tipo no esperado, lo pone al final
                    sortable_ts = datetime.datetime.min

                # Solución al error: Si el datetime tiene información de zona horaria ("offset-aware"),
                # se la quitamos para que se pueda comparar con fechas que no la tienen ("offset-naive").
                if sortable_ts and sortable_ts.tzinfo:
                    return sortable_ts.replace(tzinfo=None)
                return sortable_ts

            # Se utiliza la nueva función para ordenar la lista de ventas de forma segura
            sorted_sales = sorted(sales_list, key=get_sortable_timestamp, reverse=True)

            for row, sale in enumerate(sorted_sales):
                timestamp_val = sale.get('timestamp')
                ts_str = "Fecha inválida"
                if isinstance(timestamp_val, datetime.datetime):
                    ts_str = timestamp_val.strftime('%Y-%m-%d %H:%M:%S')
                elif isinstance(timestamp_val, str):
                    try:
                        ts_str = datetime.datetime.fromisoformat(timestamp_val).strftime('%Y-%m-%d %H:%M:%S')
                    except ValueError:
                        pass

                self.table.setItem(row, 0, QTableWidgetItem(str(sale.get("ticket_number", ""))))
                self.table.setItem(row, 1, QTableWidgetItem(ts_str))
                self.table.setItem(row, 2, QTableWidgetItem(sale.get("customer_name", "N/A")))
                self.table.setItem(row, 3, QTableWidgetItem(sale.get("user", "")))
                self.table.setItem(row, 4, QTableWidgetItem(sale.get("payment_method", "N/A")))
                self.table.setItem(row, 5, QTableWidgetItem(f"${sale.get('total', 0.0):.2f}"))
                self.table.setItem(row, 6, QTableWidgetItem(sale.get("status", "")))
        except Exception as e:
            QMessageBox.critical(self, "Error de Carga", f"No se pudo cargar el historial de ventas: {e}")
            
    def load_all_sales(self):
        query = db.collection('sales')
        self.load_sales(query)
        
    def load_today_sales(self):
        today = datetime.date.today()
        start_of_day = datetime.datetime.combine(today, datetime.time.min).isoformat()
        end_of_day = datetime.datetime.combine(today, datetime.time.max).isoformat()
        query = db.collection('sales').where('timestamp', '>=', start_of_day).where('timestamp', '<=', end_of_day)
        self.load_sales(query)
        
    def load_date_range_sales(self):
        start_date = self.start_date_edit.date().toPyDate()
        end_date = self.end_date_edit.date().toPyDate()
        start_of_day = datetime.datetime.combine(start_date, datetime.time.min).isoformat()
        end_of_day = datetime.datetime.combine(end_date, datetime.time.max).isoformat()
        query = db.collection('sales').where('timestamp', '>=', start_of_day).where('timestamp', '<=', end_of_day)
        self.load_sales(query)

class ReturnScreen(QWidget):
    return_processed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.found_sale = None
        self.found_sale_id = None
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        title = QLabel("Devoluciones", self)
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        
        search_layout = QHBoxLayout()
        self.ticket_input = QLineEdit(self)
        self.ticket_input.setPlaceholderText("Ingrese Número de Ticket")
        search_btn = QPushButton("Buscar Ticket")
        search_layout.addWidget(QLabel("Ticket:"))
        search_layout.addWidget(self.ticket_input)
        search_layout.addWidget(search_btn)
        
        self.details_text = QTextEdit(self)
        self.details_text.setReadOnly(True)
        
        self.process_button = QPushButton("Procesar Devolución")
        self.process_button.setEnabled(False)
        
        layout.addWidget(title)
        layout.addLayout(search_layout)
        layout.addWidget(self.details_text)
        layout.addWidget(self.process_button)

        self.ticket_input.returnPressed.connect(self.search_ticket)
        search_btn.clicked.connect(self.search_ticket)
        self.process_button.clicked.connect(self.process_return)

    def search_ticket(self):
        self.details_text.clear()
        self.process_button.setEnabled(False)
        self.found_sale = None
        self.found_sale_id = None
        
        try:
            ticket_number = int(self.ticket_input.text())
        except ValueError:
            QMessageBox.warning(self, "Entrada inválida", "El número de ticket debe ser un número.")
            return

        try:
            query = db.collection('sales').where('ticket_number', '==', ticket_number).limit(1)
            docs = query.stream()
            sale_doc = next(docs, None)
            
            if not sale_doc:
                self.details_text.setText(f"No se encontró ninguna venta con el ticket N° {ticket_number}.")
                return
            
            self.found_sale = sale_doc.to_dict()
            self.found_sale_id = sale_doc.id
            ticket_text = generate_ticket_text(self.found_sale)
            
            sale_status = self.found_sale.get('status', 'DESCONOCIDO')
            status_text = f"\nESTADO ACTUAL: {sale_status}"
            self.details_text.setText(ticket_text + status_text)
            
            if sale_status == "COMPLETADA":
                self.process_button.setEnabled(True)
            else:
                self.details_text.append("\n\nEsta venta no se puede devolver.")
        except Exception as e:
            QMessageBox.critical(self, "Error Inesperado", f"Ocurrió un error al buscar el ticket: {e}")
            
    def process_return(self):
        if not self.found_sale: return
        
        reply = QMessageBox.question(self, "Confirmar Devolución", "¿Está seguro de realizar la devolución de este ticket?", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.No: return

        try:
            batch = db.batch()
            for item in self.found_sale.get("items", []):
                item_ref = db.collection('inventory').document(item.get("sku"))
                batch.update(item_ref, {'quantity': firestore.Increment(item.get("quantity", 0))})
            
            sale_ref = db.collection('sales').document(self.found_sale_id)
            batch.update(sale_ref, {"status": "DEVUELTA"})
            batch.commit()

            QMessageBox.information(self, "Éxito", "Devolución procesada correctamente.")
            self.return_processed.emit()
            self.details_text.clear()
            self.ticket_input.clear()
            self.process_button.setEnabled(False)
        except Exception as e:
            QMessageBox.critical(self, "Error de Devolución", f"No se pudo procesar la devolución: {e}")

class CashCountScreen(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_user_id = "N/A"
        self.summary_text = ""
        self.init_ui()

    def set_current_user(self, user_id):
        self.current_user_id = user_id

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        title = QLabel("Corte de Caja Diario", self)
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        
        self.summary_label = QLabel("Calculando...", self)
        self.summary_label.setStyleSheet("font-family: Courier; font-size: 15px;")
        self.summary_label.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        self.process_button = QPushButton("Iniciar Corte de Caja y Salir")
        
        layout.addWidget(title)
        layout.addWidget(self.summary_label, 1)
        layout.addWidget(self.process_button)

        self.process_button.clicked.connect(self.perform_cash_count)
        
    def calculate_summary(self):
        try:
            today = datetime.date.today()
            start_of_day = datetime.datetime.combine(today, datetime.time.min).isoformat()
            end_of_day = datetime.datetime.combine(today, datetime.time.max).isoformat()
            
            sales_query = db.collection('sales').where('timestamp', '>=', start_of_day).where('timestamp', '<=', end_of_day).stream()
            
            today_sales = []
            today_returns = []
            for doc in sales_query:
                sale = doc.to_dict()
                if sale.get('status') == 'COMPLETADA': today_sales.append(sale)
                elif sale.get('status') == 'DEVUELTA': today_returns.append(sale)

            total_cash = sum(s['total'] for s in today_sales if s.get('payment_method') == 'Efectivo')
            total_card = sum(s['total'] for s in today_sales if s.get('payment_method') == 'Tarjeta Bancaria')
            total_transfer = sum(s['total'] for s in today_sales if s.get('payment_method') == 'Transferencia Bancaria')
            total_gross = sum(s['total'] for s in today_sales)
            total_returned = sum(s['total'] for s in today_returns)
            total_net = total_gross - total_returned

            self.summary_text = (
                f"--- Desglose de Ventas ---\n\n"
                f"Ventas en Efectivo: ${total_cash:.2f}\n"
                f"Ventas con Tarjeta: ${total_card:.2f}\n"
                f"Ventas con Transferencia: ${total_transfer:.2f}\n"
                f"----------------------------------------\n"
                f"Total Ventas Bruto: ${total_gross:.2f}\n\n"
                f"Devoluciones del Día: -${total_returned:.2f}\n"
                f"========================================\n"
                f"Total Neto en Caja: ${total_net:.2f}"
            )
            self.summary_label.setText(self.summary_text)
        except Exception as e:
            self.summary_label.setText(f"Error al calcular el resumen:\n{e}")

    def perform_cash_count(self):
        reply = QMessageBox.question(self, "Confirmar Corte de Caja", 
            "¿Está seguro de realizar el corte? Se generará un PDF de respaldo y la aplicación se cerrará.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            
        if reply == QMessageBox.StandardButton.Yes:
            pdf_path = generate_cash_count_pdf(self.summary_text, self.current_user_id)
            QMessageBox.information(self, "Corte Realizado", f"El corte de caja se ha guardado en:\n{pdf_path}\n\nLa aplicación se cerrará ahora.")
            QApplication.instance().quit()

# --- INICIO DE LA MODIFICACIÓN ---
# La pantalla de Ajustes ahora incluye la configuración de correo.
class SettingsScreen(QWidget):
    theme_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()
        self.load_settings()

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        title = QLabel("Ajustes Generales", self)
        title.setStyleSheet("font-size: 18px; font-weight: bold;")
        layout.addWidget(title)
        
        # --- Sección de Apariencia ---
        appearance_form = QFormLayout()
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["Oscuro", "Claro"])
        self.color_combo = QComboBox()
        self.color_combo.addItems(["Azul", "Naranja", "Verde"])
        
        appearance_form.addRow("Modo de Apariencia:", self.mode_combo)
        appearance_form.addRow("Color del Tema:", self.color_combo)
        layout.addLayout(appearance_form)

        # --- Sección de Configuración de Correo ---
        email_title = QLabel("Configuración de Correo (para envío de tickets)", self)
        email_title.setStyleSheet("font-size: 16px; font-weight: bold; margin-top: 20px;")
        layout.addWidget(email_title)

        email_form = QFormLayout()
        self.email_input = QLineEdit()
        self.email_input.setPlaceholderText("ejemplo@gmail.com")
        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText("Contraseña de aplicación de 16 letras")
        self.password_input.setEchoMode(QLineEdit.EchoMode.Password)

        email_form.addRow("Correo de Envío (Gmail):", self.email_input)
        email_form.addRow("Contraseña de Aplicación:", self.password_input)
        layout.addLayout(email_form)

        # --- Botones de Acción ---
        self.save_button = QPushButton("Guardar Cambios")
        update_button = QPushButton("Buscar Actualizaciones")
        
        button_layout = QHBoxLayout()
        button_layout.addWidget(self.save_button)
        button_layout.addWidget(update_button)
        button_layout.addStretch()

        layout.addLayout(button_layout)
        layout.addStretch()

        # Conexiones
        self.mode_combo.currentTextChanged.connect(self.save_app_config)
        self.color_combo.currentTextChanged.connect(self.save_app_config)
        self.save_button.clicked.connect(self.save_all_settings)
        update_button.clicked.connect(self.check_for_updates)

    def load_settings(self):
        try:
            # Cargar config de apariencia
            app_config_doc = db.collection('config').document('app_config').get()
            if app_config_doc.exists:
                app_config = app_config_doc.to_dict()
                self.mode_combo.setCurrentText(app_config.get("appearance_mode", "Oscuro"))
                self.color_combo.setCurrentText(app_config.get("color_theme", "Azul"))
            
            # Cargar config de correo
            email_config_doc = db.collection('config').document('email_config').get()
            if email_config_doc.exists:
                email_config = email_config_doc.to_dict()
                self.email_input.setText(email_config.get("sender_email", ""))
                self.password_input.setText(email_config.get("sender_password", ""))
        except Exception as e:
            QMessageBox.warning(self, "Error de Carga", f"No se pudieron cargar los ajustes: {e}")

    def save_app_config(self):
        """ Guarda solo la configuración de apariencia al cambiar los combos. """
        try:
            config_ref = db.collection('config').document('app_config')
            config_ref.update({
                "appearance_mode": self.mode_combo.currentText(),
                "color_theme": self.color_combo.currentText()
            })
            self.theme_changed.emit()
        except Exception as e:
            QMessageBox.warning(self, "Error al Guardar", f"No se pudo guardar la configuración de apariencia: {e}")

    def save_all_settings(self):
        """ Guarda toda la configuración, incluyendo el correo. """
        self.save_app_config() # Guarda tema y modo
        try:
            email_config_ref = db.collection('config').document('email_config')
            email_config_ref.set({
                "sender_email": self.email_input.text(),
                "sender_password": self.password_input.text()
            })
            QMessageBox.information(self, "Éxito", "Configuración guardada correctamente.")
        except Exception as e:
            QMessageBox.warning(self, "Error al Guardar", f"No se pudo guardar la configuración de correo: {e}")

    def check_for_updates(self):
        QMessageBox.information(self, "Actualizaciones", "Su sistema está actualizado a la última versión.")
# --- FIN DE LA MODIFICACIÓN ---

class MainScreen(QWidget):
    logout_requested = pyqtSignal()
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_user_id = None
        self.permissions = {}
        self.init_ui()
        
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_time)
        self.timer.start(1000)
        self.update_time()

    def set_user_permissions(self, permissions, user_id):
        self.permissions = permissions
        self.current_user_id = user_id
        self.sales_view.set_current_user(user_id) 
        self.cash_count_view.set_current_user(user_id)
        self.welcome_label.setText(f"Usuario: {self.current_user_id}")
        
        self.sales_button.setVisible(self.permissions.get('can_sell', False))
        self.inventory_button.setVisible(self.permissions.get('can_manage_inventory', False))
        self.history_button.setVisible(self.permissions.get('can_view_history', False))
        self.return_button.setVisible(self.permissions.get('can_process_returns', False))
        self.admin_button.setVisible(self.permissions.get('can_manage_users', False))
        self.settings_button.setVisible(self.permissions.get('can_view_settings', False))
        self.cash_count_button.setVisible(self.permissions.get('can_do_cash_count', False))
        
    def init_ui(self):
        main_layout = QHBoxLayout(self)
        nav_bar = QFrame(self)
        nav_bar.setFrameShape(QFrame.Shape.StyledPanel)
        nav_bar.setFixedWidth(200) 
        nav_layout = QVBoxLayout(nav_bar)
        
        logo_label = QLabel(self)
        logo_path = resource_path("logo.jpg")
        if os.path.exists(logo_path):
            pixmap = QPixmap(logo_path)
            logo_label.setPixmap(pixmap.scaledToWidth(150, Qt.TransformationMode.SmoothTransformation))
            logo_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        else:
            logo_label.setText("BOUTIQUE EL IMPULSO")
            logo_label.setStyleSheet("font-size: 16px; font-weight: bold;")
            logo_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        self.clock_label = QLabel("", self)
        self.clock_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.clock_label.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")

        self.welcome_label = QLabel("Bienvenido", self)
        self.welcome_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        
        self.sales_button = QPushButton("Punto de Venta", self)
        self.inventory_button = QPushButton("Inventario", self)
        self.history_button = QPushButton("Historial de Ventas", self)
        self.return_button = QPushButton("Devoluciones", self)
        self.admin_button = QPushButton("Gestión de Usuarios", self)
        self.settings_button = QPushButton("Ajustes", self)
        self.cash_count_button = QPushButton("Corte de Caja", self)
        logout_button = QPushButton("Cerrar Sesión", self)
        
        nav_layout.addWidget(logo_label)
        nav_layout.addWidget(self.clock_label)
        nav_layout.addWidget(self.welcome_label)
        nav_layout.addSpacing(20)
        nav_layout.addWidget(self.sales_button)
        nav_layout.addWidget(self.inventory_button)
        nav_layout.addWidget(self.history_button)
        nav_layout.addWidget(self.return_button)
        nav_layout.addWidget(self.admin_button)
        nav_layout.addWidget(self.settings_button)
        nav_layout.addStretch()
        nav_layout.addWidget(self.cash_count_button)
        nav_layout.addWidget(logout_button)
        
        self.content_stack = QStackedWidget(self)
        self.sales_view = SalesScreen(self)
        self.inventory_view = InventoryScreen(self)
        self.history_view = SalesHistoryScreen(self)
        self.return_view = ReturnScreen(self)
        self.admin_view = UserManagementScreen(self)
        self.settings_view = SettingsScreen(self)
        self.cash_count_view = CashCountScreen(self)

        self.content_stack.addWidget(self.sales_view)
        self.content_stack.addWidget(self.inventory_view)
        self.content_stack.addWidget(self.history_view)
        self.content_stack.addWidget(self.return_view)
        self.content_stack.addWidget(self.admin_view)
        self.content_stack.addWidget(self.settings_view)
        self.content_stack.addWidget(self.cash_count_view)
        
        main_layout.addWidget(nav_bar)
        main_layout.addWidget(self.content_stack, stretch=1)
        
        logout_button.clicked.connect(self.logout_requested.emit)
        self.sales_button.clicked.connect(lambda: self.content_stack.setCurrentIndex(0))
        self.inventory_button.clicked.connect(lambda: self.content_stack.setCurrentIndex(1))
        self.history_button.clicked.connect(lambda: self.content_stack.setCurrentIndex(2))
        self.return_button.clicked.connect(lambda: self.content_stack.setCurrentIndex(3))
        self.admin_button.clicked.connect(lambda: self.content_stack.setCurrentIndex(4))
        self.settings_button.clicked.connect(lambda: self.content_stack.setCurrentIndex(5))
        self.cash_count_button.clicked.connect(self.show_cash_count)

        self.sales_view.sale_finalized.connect(self.inventory_view.load_inventory)
        self.sales_view.sale_finalized.connect(self.history_view.load_today_sales)
        self.return_view.return_processed.connect(self.inventory_view.load_inventory)
        self.return_view.return_processed.connect(self.history_view.load_today_sales)
        self.inventory_view.inventory_changed.connect(self.sales_view.setup_completer)
        
    def show_cash_count(self):
        self.cash_count_view.calculate_summary()
        self.content_stack.setCurrentIndex(6)
        
    def update_time(self):
        now = datetime.datetime.now()
        date_str = now.strftime("%Y-%m-%d")
        time_str = now.strftime("%H:%M:%S")
        self.clock_label.setText(f"{date_str}\n{time_str}")

class BarcodeGeneratorDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Generador de Códigos de Barras")
        self.setMinimumSize(600, 500)
        
        self.layout = QVBoxLayout(self)
        
        self.table = QTableWidget(self)
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels(["Producto (SKU)", "Seleccionar", "Cantidad de Etiquetas"])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.table.setSelectionMode(QTableWidget.SelectionMode.NoSelection)

        button_layout = QHBoxLayout()
        select_all_btn = QPushButton("Seleccionar Todo")
        deselect_all_btn = QPushButton("Quitar Selección")
        generate_btn = QPushButton("Generar PDF")
        
        button_layout.addWidget(select_all_btn)
        button_layout.addWidget(deselect_all_btn)
        button_layout.addStretch()
        button_layout.addWidget(generate_btn)

        self.layout.addWidget(self.table)
        self.layout.addLayout(button_layout)
        
        select_all_btn.clicked.connect(lambda: self.toggle_all_checkboxes(True))
        deselect_all_btn.clicked.connect(lambda: self.toggle_all_checkboxes(False))
        generate_btn.clicked.connect(self.generate_pdf)
        
        self.load_products()

    def load_products(self):
        try:
            inventory_docs = db.collection('inventory').stream()
            products = {doc.id: doc.to_dict() for doc in inventory_docs}
            self.table.setRowCount(len(products))

            for row, (sku, data) in enumerate(products.items()):
                item_text = f"{data.get('name', 'N/A')} [{sku}]"
                self.table.setItem(row, 0, QTableWidgetItem(item_text))

                checkbox_widget = QWidget()
                chk_layout = QHBoxLayout(checkbox_widget)
                chk = QCheckBox()
                chk_layout.addWidget(chk)
                chk_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                chk_layout.setContentsMargins(0,0,0,0)
                self.table.setCellWidget(row, 1, checkbox_widget)

                qty_input = QLineEdit("1")
                qty_input.setValidator(QDoubleValidator(1, 1000, 0))
                self.table.setCellWidget(row, 2, qty_input)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"No se pudo cargar la lista de productos: {e}")

    def toggle_all_checkboxes(self, checked):
        for row in range(self.table.rowCount()):
            widget = self.table.cellWidget(row, 1)
            if widget:
                checkbox = widget.findChild(QCheckBox)
                checkbox.setChecked(checked)

    def generate_pdf(self):
        selected_products = []
        for row in range(self.table.rowCount()):
            widget = self.table.cellWidget(row, 1)
            checkbox = widget.findChild(QCheckBox)
            if checkbox and checkbox.isChecked():
                sku = self.table.item(row, 0).text().split('[')[-1].split(']')[0]
                qty_widget = self.table.cellWidget(row, 2)
                quantity = int(qty_widget.text())
                selected_products.append({"sku": sku, "quantity": quantity})
        
        if not selected_products:
            QMessageBox.warning(self, "Sin Selección", "Por favor, seleccione al menos un producto.")
            return

        folder = resource_path("barcodes")
        os.makedirs(folder, exist_ok=True)
        filename = os.path.join(folder, f"barcodes_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf")

        try:
            pdf = FPDF(orientation='P', unit='mm', format='A4')
            pdf.add_page()
            pdf.set_auto_page_break(True, margin=10)
            
            # Dimensiones de la etiqueta y márgenes
            label_width = 60
            label_height = 25
            margin_x = 10
            margin_y = 10
            
            col, row_count = 0, 0
            
            temp_barcode_files = []

            for product in selected_products:
                doc = db.collection('inventory').document(product["sku"]).get()
                if not doc.exists: continue
                
                data = doc.to_dict()
                
                for _ in range(product["quantity"]):
                    x = margin_x + (col * (label_width + 5))
                    y = margin_y + (row_count * (label_height + 5))
                    
                    # Generar código de barras
                    barcode_path = resource_path(f'temp_barcode_{product["sku"]}.png')
                    code128 = Code128(product["sku"], writer=ImageWriter())
                    code128.write(barcode_path, options={"write_text": False, "module_height": 8.0, "font_size": 0, "text_distance": 0})
                    temp_barcode_files.append(barcode_path)

                    # Dibujar en el PDF
                    # Nombre del producto
                    pdf.set_xy(x, y)
                    pdf.set_font("Helvetica", size=8)
                    pdf.multi_cell(label_width, 4, data.get("name", ""), align='C', border=0)
                    
                    # Código de barras
                    barcode_y = y + 5
                    pdf.image(barcode_path, x=x + 5, y=barcode_y, w=label_width - 10, h=10)
                    
                    # SKU y Precio
                    info_y = barcode_y + 11
                    pdf.set_xy(x, info_y)
                    pdf.set_font("Helvetica", size=9)
                    info_text = f"{product['sku']} - ${data.get('price', 0.0):.2f}"
                    pdf.cell(label_width, 5, info_text, align='C', border=0)

                    col += 1
                    if col >= 3:
                        col = 0
                        row_count += 1
                        if row_count >= 10:
                            row_count = 0
                            pdf.add_page()
            
            pdf.output(filename)
            QMessageBox.information(self, "Éxito", f"PDF con códigos de barras guardado en:\n{filename}")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"No se pudo generar el PDF: {e}")
        finally:
            for f in temp_barcode_files:
                if os.path.exists(f): os.remove(f)
            self.close()

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Sistema Punto de Venta (PyQt6)")
        self.setGeometry(100, 100, 1200, 700)
        
        self.login_screen = LoginScreen()
        self.main_screen = MainScreen()

        self.stacked_widget = QStackedWidget()
        self.stacked_widget.addWidget(self.login_screen)
        self.stacked_widget.addWidget(self.main_screen)
        
        self.setCentralWidget(self.stacked_widget)
        
        self.login_screen.login_successful.connect(self.show_main_screen)
        self.main_screen.logout_requested.connect(self.show_login_screen)
        self.main_screen.settings_view.theme_changed.connect(self.apply_stylesheet)
        self.show_login_screen()

    def show_login_screen(self):
        self.main_screen.sales_view.current_sale_items = []
        self.main_screen.sales_view.update_cart_display()
        self.main_screen.sales_view.customer_name_input.clear()
        self.stacked_widget.setCurrentIndex(0)

    def show_main_screen(self, permissions, user_id):
        self.main_screen.set_user_permissions(permissions, user_id)
        self.main_screen.sales_view.setup_completer()
        self.stacked_widget.setCurrentIndex(1)
        
    def create_backup(self):
        backup_folder = resource_path('backups')
        os.makedirs(backup_folder, exist_ok=True)
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        # Aquí se necesitaría una forma de exportar la colección de Firestore,
        # lo cual es una operación más compleja y generalmente se hace desde la consola de Google Cloud.
        # Por ahora, esta función queda como placeholder.
        print(f"La copia de seguridad de Firestore debe realizarse desde la consola de Google Cloud.")
        return True

    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'Confirmar Salida',
                                     "¿Está seguro de que desea salir?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                     QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.Yes:
            event.accept()
        else:
            event.ignore()
        
    def apply_stylesheet(self):
        try:
            config_doc = db.collection('config').document('app_config').get()
            config = config_doc.to_dict() if config_doc.exists else {}
        except Exception as e:
            print(f"No se pudo cargar la configuración de tema: {e}")
            config = {}
            
        mode = config.get("appearance_mode", "Oscuro")
        theme = config.get("color_theme", "Azul")
        
        palettes = {
            "Oscuro": {"base": "#2e2e2e", "alt_base": "#3c3c3c", "text": "#e0e0e0", "button": "#4a4a4a", "button_hover": "#5a5a5a", "button_pressed": "#404040", "border": "#555555", "header": "#454545"},
            "Claro": {"base": "#f5f5f5", "alt_base": "#ffffff", "text": "#212121", "button": "#e0e0e0", "button_hover": "#eeeeee", "button_pressed": "#bdbdbd", "border": "#cccccc", "header": "#f0f0f0"}
        }
        accent_colors = {
            "Azul": ("#3498db", "#ffffff"),
            "Naranja": ("#e67e22", "#ffffff"),
            "Verde": ("#2ecc71", "#ffffff")
        }
        
        p = palettes.get(mode, palettes["Oscuro"])
        accent, accent_text = accent_colors.get(theme, accent_colors["Azul"])

        style = f"""
            QWidget {{ background-color: {p["base"]}; color: {p["text"]}; font-size: 14px; }}
            QMainWindow {{ border: 1px solid {p["border"]}; }}
            QFrame, QDialog {{ background-color: {p["alt_base"]}; }}
            
            QPushButton {{ background-color: {p["button"]}; border: 1px solid {p["border"]}; padding: 8px; border-radius: 5px; text-align: left; padding-left: 10px; }}
            QPushButton:hover {{ background-color: {p["button_hover"]}; }}
            QPushButton:pressed {{ background-color: {p["button_pressed"]}; }}
            
            QLineEdit, QDateEdit, QComboBox, QTextEdit {{ background-color: {p["base"]}; border: 1px solid {p["border"]}; padding: 6px; border-radius: 5px; }}
            QTableWidget {{ gridline-color: {p["border"]}; background-color: {p["base"]}; }}
            QHeaderView::section {{ background-color: {p["header"]}; padding: 4px; border: 1px solid {p["border"]}; font-weight: bold; }}
            
            QScrollBar:vertical {{ border: none; background: {p["base"]}; width: 14px; }}
            QScrollBar::handle:vertical {{ background: {p["button"]}; min-height: 20px; border-radius: 4px; }}
            QScrollBar:horizontal {{ border: none; background: {p["base"]}; height: 14px; }}
            QScrollBar::handle:horizontal {{ background: {p["button"]}; min-width: 20px; border-radius: 4px; }}
            
            QCheckBox::indicator {{ width: 18px; height: 18px; border: 1px solid {p["border"]}; border-radius: 4px; }}
            QCheckBox::indicator:unchecked {{ background-color: {p["base"]}; }}
            QCheckBox::indicator:checked {{ background-color: {accent}; }}

            QFrame#leftPanel {{ background-color: {p["alt_base"]}; border: none; }}
            QFrame#leftPanel QLabel, QFrame#leftPanel QLineEdit, QFrame#leftPanel QPushButton {{ font-size: 16px; }}
            QFrame#leftPanel QLineEdit {{ padding: 8px; }}

            QLabel#greetingLabel {{ color: {accent_text}; background-color: rgba(0, 0, 0, 0.7); padding: 20px; border-radius: 8px; font-size: 48px; font-weight: bold; }}
            QLabel#footerLabel {{ color: {accent_text}; background-color: rgba(0, 0, 0, 0.7); padding: 8px; border-radius: 5px; font-size: 16px; }}
            QPushButton#loginButton, QPushButton#recoverButton {{ background-color: {accent}; color: {accent_text}; text-align: center; font-weight: bold; height: 44px; font-size: 16px; }}
            QPushButton#loginButton:hover, QPushButton#recoverButton:hover {{ background-color: {p["button_hover"]}; }}
        """
        self.setStyleSheet(style)


def run_pre_flight_checks():
    global db
    try:
        from barcode import Code128
        from barcode.writer import ImageWriter
    except ImportError:
        QMessageBox.critical(None, "Librería Faltante", "La librería 'python-barcode' es necesaria.\n\nInstálela con: pip install python-barcode Pillow")
        return False
    try:
        cred_path = resource_path('serviceAccountKey.json')
        if not os.path.exists(cred_path):
            QMessageBox.critical(None, "Archivo no Encontrado", "No se encontró 'serviceAccountKey.json'. Siga las instrucciones para configurar la base de datos.")
            return False
        if not firebase_admin._apps:
            cred = credentials.Certificate(cred_path)
            firebase_admin.initialize_app(cred)
        db = firestore.client()
        print("Conexión exitosa a Firebase.")
        return True
    except Exception as e:
        QMessageBox.critical(None, "Error de Conexión a Firebase", f"No se pudo conectar a Firebase.\n\nError: {e}")
        return False

# --- Punto de Entrada de la Aplicación ---
if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    if not run_pre_flight_checks():
        sys.exit(1)

    setup_database()
    
    window = MainWindow()
    window.apply_stylesheet()
    window.show()
    sys.exit(app.exec())

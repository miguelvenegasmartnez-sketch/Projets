import customtkinter as ctk
from tkinter import messagebox, simpledialog, Toplevel, Listbox, END, ttk, Text
from PIL import Image
from fpdf import FPDF
import datetime
import time
import json
import os
import sys
# --- LIBRERÍAS DE CORREO ACTIVADAS ---
import smtplib
import socket # Para verificar la conexión
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

# --- FUNCIÓN AÑADIDA PARA COMPATIBILIDAD CON .EXE ---
def resource_path(relative_path):
    """ Obtiene la ruta absoluta al recurso, funciona para desarrollo y para PyInstaller """
    try:
        # PyInstaller crea una carpeta temporal y guarda la ruta en _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

# --- Configuración Inicial y Simulación de Base de Datos ---

DB_FILES = {
    "users": "users.json",
    "inventory": "inventory.json",
    "sales": "sales.json",
    "config": "config.json",
    "email": "email_config.json"
}

def setup_database():
    """Inicializa los archivos JSON si no existen."""
    if not os.path.exists(DB_FILES["users"]):
        # CAMBIO: Usar EIDs como clave para cumplir con la generación automática
        admin_user = {
            "E001": {"password": "admin", "role": "administrador", "full_name": "Administrador Principal", "phone": "N/A", "email": "admin@boutique.com"},
            "E002": {"password": "123", "role": "vendedor", "full_name": "Vendedor de Prueba", "phone": "555-1234", "email": "vendedor@boutique.com"}
        }
        with open(DB_FILES["users"], "w") as f: json.dump(admin_user, f, indent=4)
    if not os.path.exists(DB_FILES["inventory"]):
        # CAMBIO: Añadir wholesale_price al inventario de muestra
        sample_inventory = {
            "SKU001": {"name": "Camisa de Lino Blanca", "price": 450.0, "quantity": 20, "wholesale_price": 400.0}, 
            "SKU002": {"name": "Pantalón de Mezclilla Azul", "price": 750.0, "quantity": 15, "wholesale_price": 700.0}
        }
        with open(DB_FILES["inventory"], "w") as f: json.dump(sample_inventory, f, indent=4)
    if not os.path.exists(DB_FILES["sales"]):
        with open(DB_FILES["sales"], "w") as f: json.dump([], f, indent=4)
    if not os.path.exists(DB_FILES["config"]):
        default_config = {
            "appearance_mode": "dark", 
            "color_theme": "blue", 
            "last_ticket_number": 0
        }
        with open(DB_FILES["config"], "w") as f: json.dump(default_config, f, indent=4)
    
    if not os.path.exists(DB_FILES["email"]):
        email_config = {
            "smtp_server": "smtp.gmail.com",
            "smtp_port": 587,
            "sender_email": "boutiqueelimpulso@gmail.com",
            "sender_password": "xozx zfsz pshy difc"
        }
        with open(DB_FILES["email"], "w") as f:
            json.dump(email_config, f, indent=4)

def read_db(file_key):
    with open(DB_FILES[file_key], "r", encoding='utf-8') as f: return json.load(f)

def write_db(file_key, data):
    with open(DB_FILES[file_key], "w", encoding='utf-8') as f: 
        json.dump(data, f, indent=4, ensure_ascii=False)

# --- NUEVA FUNCIÓN: GENERADOR DE ID DE EMPLEADO ---
def get_next_employee_id():
    users = read_db("users")
    max_id_num = 0
    # Buscar el número más alto entre las claves que empiezan con 'E'
    for username in users.keys():
        if username.startswith("E") and username[1:].isdigit():
            try:
                num = int(username[1:])
                if num > max_id_num:
                    max_id_num = num
            except ValueError:
                continue 
    return f"E{max_id_num + 1:03d}"
# --------------------------------------------------

# --- FUNCIÓN RESTAURADA AL TEMA BASE Y ESTABLE ---
def apply_ui_settings():
    config = read_db("config")
    ctk.set_appearance_mode(config.get("appearance_mode", "dark"))
    
    # Aplicar el tema base estable
    theme = config.get("color_theme", "blue")
    if theme not in ["blue", "dark-blue", "green"]:
        ctk.set_default_color_theme("blue")
    else:
        ctk.set_default_color_theme(theme)


def create_pdf_with_logo(business_name, title, content, filename, align='C'):
    pdf = FPDF()
    pdf.add_page()
    logo_path = resource_path("logo.jpg")
    if os.path.exists(logo_path):
        page_width = pdf.w - 2 * pdf.l_margin
        pdf.image(logo_path, x=(page_width / 2) + pdf.l_margin - 15, y=8, w=30)
        pdf.ln(30)
    
    pdf.set_font("Arial", 'B', 20)
    pdf.cell(0, 10, business_name, 0, 1, 'C')
    pdf.set_font("Arial", 'I', 14)
    pdf.cell(0, 10, title, 0, 1, 'C')
    pdf.ln(10)

    pdf.set_font("Courier", size=10)
    pdf.multi_cell(0, 5, txt=content.encode('latin-1', 'replace').decode('latin-1'), align=align)

    pdf.output(filename)
    print(f"Reporte '{filename}' generado.")

# --- Clase Principal de la Aplicación ---
class POSApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        apply_ui_settings()
        self.title("Sistema Punto de Venta - Tienda de Ropa")
        # Mantener geometría fija para la ventana principal
        self.geometry("1200x700") 
        self.current_user = None
        self.current_user_role = None
        self.container = ctk.CTkFrame(self)
        self.container.pack(side="top", fill="both", expand=True)
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)
        self.frames = {}
        self.show_frame("LoginScreen")
    
    def show_frame(self, page_name):
        frame_class = globals().get(page_name)
        if frame_class:
            frame = frame_class(parent=self.container, controller=self)
            self.frames[page_name] = frame
            frame.grid(row=0, column=0, sticky="nsew")
            frame.tkraise()

    # --- CORRECCIÓN DEL ERROR DE LOGIN ---
    def login(self, username_raw, password):
        # Normalizar a mayúsculas para buscar EIDs (E001, E002, etc.)
        username = username_raw.strip().upper() 
        users = read_db("users")

        # LÓGICA DE ALIAS: Si el usuario ingresa 'ADMIN', usamos E001 como clave de búsqueda.
        if username == "ADMIN":
            key_to_check = "E001"
        else:
            key_to_check = username
        
        if key_to_check in users and users[key_to_check]["password"] == password:
            self.current_user = key_to_check # Usa el EID como usuario actual
            self.current_user_role = users[key_to_check]["role"]
            self.show_frame("MainScreen")
        else: messagebox.showerror("Error de Autenticación", "Usuario o contraseña incorrectos.")
    # --------------------------------------
        
    def logout(self):
        self.current_user = None
        self.current_user_role = None
        if "MainScreen" in self.frames: self.frames["MainScreen"].destroy()
        if "MainScreen" in self.frames: del self.frames["MainScreen"]
        self.show_frame("LoginScreen")

# --- Pantalla de Login con Nuevo Diseño ---
class LoginScreen(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        
        # 1. Configurar Grid para el diseño de dos columnas (Panel Izquierdo y Visual Derecho)
        self.grid_columnconfigure(0, weight=0, minsize=350) # Panel Izquierdo fijo
        self.grid_columnconfigure(1, weight=1)              # Panel Derecho flexible
        self.grid_rowconfigure(0, weight=1)

        # --- PANEL IZQUIERDO: Navegación/Branding (Light background) ---
        left_panel = ctk.CTkFrame(self, fg_color=("white", "gray20"), corner_radius=0)
        left_panel.grid(row=0, column=0, sticky="nsew")
        left_panel.grid_columnconfigure(0, weight=1)

        # --- LOGO y Nombre de la Empresa (REEMPLAZO DE TEXTO 1) ---
        try:
            logo_image_path = resource_path("logo.jpg")
            # Adaptamos el logo existente al diseño de "Fundación Ayuda Mutua"
            logo_image = ctk.CTkImage(light_image=Image.open(logo_image_path), size=(120, 120))
            logo_label = ctk.CTkLabel(left_panel, image=logo_image, text="BOUTIQUE EL IMPULSO", # <--- TEXTO MODIFICADO
                                      font=ctk.CTkFont(size=14, weight="bold"), compound="top", 
                                      text_color=("black", "white"), pady=20)
            logo_label.pack(pady=(40, 20), padx=30)
        except Exception as e:
            print(f"Error cargando logo en login: {e}")
            ctk.CTkLabel(left_panel, text="BOUTIQUE EL IMPULSO", font=ctk.CTkFont(size=18, weight="bold"), # <--- TEXTO MODIFICADO
                         text_color=("black", "white")).pack(pady=(40, 20), padx=30)
            
        # --- Campos de Login y Botones ---
        login_frame = ctk.CTkFrame(left_panel, fg_color="transparent")
        login_frame.pack(pady=40, padx=20, fill="x", expand=True)
        
        # Entradas
        ctk.CTkLabel(login_frame, text="Usuario (E### o admin):", fg_color="transparent", text_color=("black", "white"), anchor="w").pack(anchor="w", pady=(10, 0))
        self.username_entry = ctk.CTkEntry(login_frame, placeholder_text="E001 / admin", width=250)
        self.username_entry.pack(pady=(0, 10), padx=0, fill="x")
        
        ctk.CTkLabel(login_frame, text="Contraseña:", fg_color="transparent", text_color=("black", "white"), anchor="w").pack(anchor="w", pady=(10, 0))
        self.password_entry = ctk.CTkEntry(login_frame, placeholder_text="Contraseña", show="*", width=250)
        self.password_entry.pack(pady=(0, 20), padx=0, fill="x")
        
        self.password_entry.bind("<Return>", lambda event: self.controller.login(self.username_entry.get(), self.password_entry.get()))
        
        # Botón INICIAR SESIÓN (Adaptado al color naranja del diseño)
        login_button = ctk.CTkButton(login_frame, text="INICIAR SESIÓN", 
                                     command=lambda: self.controller.login(self.username_entry.get(), self.password_entry.get()), 
                                     fg_color="#f59e0b", hover_color="#d97706", height=40, text_color="white")
        login_button.pack(pady=(10, 20), fill="x")

        # Botón RECUPERAR CONTRASEÑA (Adaptación de "Registrar" a la funcionalidad existente)
        register_button = ctk.CTkButton(login_frame, text="RECUPERAR CONTRASEÑA", 
                                        command=lambda: self.forgot_password(None), 
                                        fg_color="#f59e0b", hover_color="#d97706", height=40, text_color="white")
        register_button.pack(pady=(0, 10), fill="x")


        # --- PANEL DERECHO: Visual y Greeting ---
        right_panel = ctk.CTkFrame(self, corner_radius=0)
        right_panel.grid(row=0, column=1, sticky="nsew")
        right_panel.grid_rowconfigure(0, weight=1)
        right_panel.grid_columnconfigure(0, weight=1)
        
        # Intentar cargar la imagen de fondo (adaptando la del proyecto)
        try:
            bg_image_path = resource_path("background.png")
            # Intentamos cargar una imagen de fondo genérica para el POS
            bg_image = ctk.CTkImage(Image.open(bg_image_path), size=(1200, 700)) 
            bg_label = ctk.CTkLabel(right_panel, image=bg_image, text="")
            bg_label.place(x=0, y=0, relwidth=1, relheight=1)
            # El color de texto se establece en blanco para alto contraste
            text_color = "white" 
        except Exception: 
            # Si falla, usa un color sólido (simulando el diseño azul)
            right_panel.configure(fg_color="#4f86a9")
            text_color = "white"

        # Título grande "¡Buen día! Bienvenido(a)"
        greeting_text = f"¡{self.get_dynamic_greeting()}!\nBienvenido(a)"
        # FIX VISUAL: Usar fg_color="transparent" y color blanco
        greeting_label = ctk.CTkLabel(right_panel, text=greeting_text, 
                                      font=ctk.CTkFont(size=40, weight="bold"), 
                                      text_color="white", # Color de texto hardcodeado a blanco
                                      fg_color="transparent") 
        greeting_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Pie de página (REEMPLAZO DE TEXTO 2)
        # FIX VISUAL: Usar fg_color="transparent" y color blanco
        footer_label = ctk.CTkLabel(right_panel, text="SISTEMA PUNTO DE VENTA BOUTIQUE EL IMPULSO", 
                                    font=ctk.CTkFont(size=14), 
                                    text_color="white", # Color de texto hardcodeado a blanco
                                    fg_color="transparent") 
        footer_label.pack(side="bottom", pady=20)
      
    def get_dynamic_greeting(self):
        h = datetime.datetime.now().hour
        if 5 <= h < 12: return "Buen día"
        elif 12 <= h < 19: return "Buena tarde"
        else: return "Buena noche"
    
    def forgot_password(self, event):
        username = simpledialog.askstring("Recuperar Contraseña", "Ingrese su número de empleado (ej. E001):", parent=self)
        if username:
            username = username.strip().upper()
            users = read_db("users")
            if username in users:
                messagebox.showinfo("Contraseña", f"La contraseña para '{username}' es: {users[username]['password']}")
            else:
                messagebox.showerror("Error", "El usuario no fue encontrado.")

# --- Pantalla Principal (Punto de Venta) ---
class MainScreen(ctk.CTkFrame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        self.current_sale_items = []
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=2)
        self.grid_rowconfigure(1, weight=1)
        top_bar = ctk.CTkFrame(self, height=50, corner_radius=0)
        top_bar.grid(row=0, column=0, columnspan=2, sticky="ew")
        try:
            logo_image_path = resource_path("logo.png")
            logo_img = ctk.CTkImage(Image.open(logo_image_path), size=(40, 40))
            ctk.CTkLabel(top_bar, image=logo_img, text="").pack(side="left", padx=10, pady=5)
        except Exception as e:
            print(f"Error cargando logo en pantalla principal: {e}")

        ctk.CTkButton(top_bar, text="Menú", command=self.open_menu).pack(side="left", padx=10, pady=10)
  
        self.time_user_label = ctk.CTkLabel(top_bar, text="", font=ctk.CTkFont(size=14))
        self.time_user_label.pack(side="right", padx=10, pady=10)
        self.update_time()
        # BOTÓN SALIR MODIFICADO
        ctk.CTkButton(top_bar, text="SALIR", command=self.controller.logout, fg_color="#c0392b", hover_color="#e74c3c").pack(side="right", padx=10, pady=10)
        sale_panel = ctk.CTkFrame(self, corner_radius=10)
        sale_panel.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        sale_panel.grid_rowconfigure(3, weight=1)
        sale_panel.grid_columnconfigure(1, weight=1)
        ctk.CTkLabel(sale_panel, text="Cliente (Opcional):").grid(row=0, column=0, padx=10, pady=10, sticky="w")
        self.customer_name_entry = ctk.CTkEntry(sale_panel, placeholder_text="Nombre del cliente")
        self.customer_name_entry.grid(row=0, column=1, columnspan=2, padx=10, pady=10, sticky="ew")
        
        ctk.CTkLabel(sale_panel, text="Añadir Producto:").grid(row=1, column=0, columnspan=3, padx=10, pady=10, sticky="w")
        self.product_search_entry = ctk.CTkEntry(sale_panel, placeholder_text="Escanear o buscar por nombre/SKU")
        self.product_search_entry.grid(row=2, column=0, columnspan=3, padx=10, pady=5, sticky="ew")
        self.product_search_entry.bind("<KeyRelease>", self.update_suggestions)
        self.product_search_entry.bind("<Return>", self.add_product_from_scanner_or_selection)
        self.suggestions_toplevel = None

        cart_panel = ctk.CTkFrame(self, corner_radius=10)
        cart_panel.grid(row=1, column=1, sticky="nsew", padx=10, pady=10)
        cart_panel.grid_columnconfigure(0, weight=1)
        cart_panel.grid_rowconfigure(0, weight=1)
        self.cart_listbox = Listbox(cart_panel, bg="#2b2b2b", fg="white", border=0, selectbackground="#1f6aa5", font=("Courier", 14))
        self.cart_listbox.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        cart_scrollbar = ctk.CTkScrollbar(cart_panel, command=self.cart_listbox.yview)
        cart_scrollbar.grid(row=0, column=1, sticky="ns")
        self.cart_listbox.configure(yscrollcommand=cart_scrollbar.set)
        cart_actions_frame = ctk.CTkFrame(cart_panel, fg_color="transparent")
        cart_actions_frame.grid(row=1, column=0, sticky="w", padx=5, pady=5)
        ctk.CTkButton(cart_actions_frame, text="Modificar Cantidad", command=self.modify_quantity).pack(side="left", padx=5)
        ctk.CTkButton(cart_actions_frame, text="Eliminar Artículo", command=self.remove_item).pack(side="left", padx=5)
        total_panel = ctk.CTkFrame(cart_panel)
        total_panel.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        total_panel.grid_columnconfigure(0, weight=1)
        total_panel.grid_columnconfigure(1, weight=1)
        self.subtotal_label = ctk.CTkLabel(total_panel, text="Subtotal: $0.00", font=ctk.CTkFont(size=20, weight="bold"))
        self.subtotal_label.grid(row=0, column=0, padx=10, pady=10, sticky="w")
        ctk.CTkButton(total_panel, text="Pagar", font=ctk.CTkFont(size=18), command=self.open_payment_window).grid(row=0, column=1, padx=10, pady=10, sticky="e")

    def update_suggestions(self, event):
        if event.keysym in ("Up", "Down", "Return", "Escape"):
            return
        search_term = self.product_search_entry.get().lower()
        if not search_term:
            self.hide_suggestions()
            return
     
        inventory = read_db("inventory")
        matches = {sku: data for sku, data in inventory.items() if search_term in data["name"].lower() or search_term in sku.lower()}
        if matches:
            if not self.suggestions_toplevel:
                self.create_suggestions_toplevel()
            self.suggestions_listbox.delete(0, END)
            for sku, data in matches.items():
   
                self.suggestions_listbox.insert(END, f"{data['name']} [{sku}]")
        else:
            self.hide_suggestions()
            
    def create_suggestions_toplevel(self):
        entry_x = self.product_search_entry.winfo_rootx()
        entry_y = self.product_search_entry.winfo_rooty() + self.product_search_entry.winfo_height()
        entry_width = self.product_search_entry.winfo_width()
        self.suggestions_toplevel = Toplevel(self)
      
        self.suggestions_toplevel.overrideredirect(True)
        self.suggestions_toplevel.geometry(f"{entry_width}x150+{entry_x}+{entry_y}")
        self.suggestions_listbox = Listbox(self.suggestions_toplevel, bg="#343638", fg="white", selectbackground="#1f6aa5", border=1, relief="solid")
        self.suggestions_listbox.pack(expand=True, fill="both")
        self.suggestions_listbox.bind("<ButtonRelease-1>", self.add_product_from_scanner_or_selection)
        self.product_search_entry.bind("<Down>", self.focus_suggestions)
        self.suggestions_listbox.bind("<Return>", self.add_product_from_scanner_or_selection)
        self.suggestions_listbox.bind("<Escape>", lambda e: self.hide_suggestions())

    def hide_suggestions(self):
        if self.suggestions_toplevel:
            self.suggestions_toplevel.destroy()
  
            self.suggestions_toplevel = None

    def focus_suggestions(self, event):
        if self.suggestions_toplevel:
            self.suggestions_listbox.focus_set()
            self.suggestions_listbox.selection_set(0)

    def add_product_from_scanner_or_selection(self, event=None):
        search_term = ""
        if self.suggestions_toplevel and self.suggestions_listbox.curselection():
            selection = self.suggestions_listbox.get(self.suggestions_listbox.curselection())
        
            search_term = selection.split('[')[-1].strip(']')
        else:
            search_term = self.product_search_entry.get().strip()
        if search_term:
            self.add_product_to_cart(search_term)
            self.product_search_entry.delete(0, 'end')
            self.hide_suggestions()
            
    def update_item_price(self, sku):
        """Aplica el precio mayorista si la cantidad es >= 3."""
        item = next((item for item in self.current_sale_items if item["sku"] == sku), None)
        if item:
            # Condición: Cantidad de 3 o más Y el precio mayorista es menor al precio normal (para evitar errores si no se configura)
            if item["quantity"] >= 3 and item["wholesale_price"] < item["regular_price"]:
                item["price"] = item["wholesale_price"]
            else:
                item["price"] = item["regular_price"]

    def add_product_to_cart(self, sku_to_add):
        inventory = read_db("inventory")
      
        sku_to_add = sku_to_add.upper()
        if sku_to_add in inventory:
            found_product = inventory[sku_to_add]
            # NEW: Asegurar que existe wholesale_price (usar precio regular como fallback)
            wholesale_price = found_product.get("wholesale_price", found_product["price"])
            
            existing_item = next((item for item in self.current_sale_items if item["sku"] == sku_to_add), None)
            
            if existing_item:
                if inventory[sku_to_add]["quantity"] > existing_item["quantity"]:
                
                    existing_item["quantity"] += 1
                else: messagebox.showwarning("Sin Stock", "No hay más stock disponible.")
            else:
                if inventory[sku_to_add]["quantity"] > 0:
                    # NEW: Almacenar ambos precios, y "price" será el precio que se use en la venta.
                    self.current_sale_items.append({
                        "sku": sku_to_add, 
                        "name": found_product["name"], 
                        "regular_price": found_product["price"], 
                        "wholesale_price": wholesale_price,
                        "price": found_product["price"], 
                        "quantity": 1
                    })
             
                else: messagebox.showwarning("Sin Stock", "El producto está agotado.")

            # NEW: Aplicar la lógica de precios después de modificar la cantidad
            self.update_item_price(sku_to_add)
            self.update_cart_display()
        else:
            messagebox.showerror("No Encontrado", f"No se encontró producto con SKU '{sku_to_add}'.")

    def update_time(self): 
        self.time_user_label.configure(text=f"Usuario: {self.controller.current_user} | Hora: {time.strftime('%H:%M:%S')}")
        self.after(1000, self.update_time)
        
    def update_cart_display(self):
        self.cart_listbox.delete(0, END)
        subtotal = 0
        for i, item in enumerate(self.current_sale_items):
            total_item_price = item["price"] * item["quantity"] # Usa el 'price' efectivo (regular o mayorista)
            display_text = f"{item['quantity']:>3}x {item['name']:<35} @ ${item['price']:<8.2f} = ${total_item_price:>8.2f}"
            self.cart_listbox.insert(END, display_text)
            subtotal += total_item_price
        self.subtotal_label.configure(text=f"Subtotal: ${subtotal:.2f}")

    def get_selected_item_index(self):
   
        if not (selected_indices := self.cart_listbox.curselection()):
            messagebox.showwarning("Sin Selección", "Por favor, seleccione un artículo de la lista.")
            return None
        return selected_indices[0]

    def modify_quantity(self):
        if (index := self.get_selected_item_index()) is None: return
        item = self.current_sale_items[index]
        inventory = read_db("inventory")
        stock_disponible = inventory[item['sku']]['quantity']
        
        new_quantity = simpledialog.askinteger("Modificar Cantidad", f"Ingrese la nueva cantidad para '{item['name']}'\n(Stock disponible: {stock_disponible})", parent=self, minvalue=1, maxvalue=stock_disponible)
        
        if new_quantity is not None: 
            item['quantity'] = new_quantity
            # NEW: Aplicar la lógica de precios después de modificar la cantidad
            self.update_item_price(item["sku"])
            # -----------------------------------------------------------------------
            self.update_cart_display()

    def remove_item(self):
        if (index := self.get_selected_item_index()) is None: return
        if messagebox.askyesno("Confirmar", f"¿Seguro que desea eliminar '{self.current_sale_items[index]['name']}' de la venta?"):
            del self.current_sale_items[index]
            self.update_cart_display()

    def open_payment_window(self):
        if not self.current_sale_items: messagebox.showwarning("Venta Vacía", "Agregue productos antes de cobrar."); return
        subtotal = sum(item['price'] * item['quantity'] for item in self.current_sale_items)
        PaymentWindow(self, subtotal)

    # --- CAMBIO SOLICITADO: CAPTURAR Y GUARDAR NOMBRE DEL CLIENTE ---
    def finalize_sale(self, payment_method, total, details):
        customer_name = self.customer_name_entry.get().strip() # Capturar el nombre del cliente
        
        config = read_db("config")
        new_ticket_number = config.get("last_ticket_number", 0) + 1
        sales = read_db("sales")
        
        # Nota: La estructura del artículo en sale_record["items"] ahora incluye regular_price y wholesale_price,
        # pero el campo "price" es el que se utilizó para el cálculo final, que es lo importante.
        sale_record = {
            "ticket_number": new_ticket_number, 
            "timestamp": datetime.datetime.now().isoformat(), 
            "user": self.controller.current_user, 
            "items": self.current_sale_items, 
            "total": total, 
            "payment_method": payment_method, 
            "details": details, 
            "status": "COMPLETADA",
            "customer_name": customer_name # Guardar el nombre
        }
        
        sales.append(sale_record)
        write_db("sales", sales)
        config["last_ticket_number"] = new_ticket_number
        write_db("config", config)
        inventory = read_db("inventory")
        for item in self.current_sale_items:
            if item["sku"] in inventory: inventory[item["sku"]]["quantity"] -= item["quantity"]
        write_db("inventory", inventory)
        ShippingOptionsWindow(self, sale_record)
    # -------------------------------------------------------------
    
    def reset_sale_screen(self):
        self.current_sale_items = []
        self.update_cart_display()
        self.customer_name_entry.delete(0, 'end')
        self.product_search_entry.delete(0, 'end')

    # --- CAMBIO SOLICITADO: MOSTRAR NOMBRE DEL CLIENTE EN EL TICKET ---
    def generate_ticket_text(self, sale_record):
        customer_name = sale_record.get('customer_name')
        if not customer_name or customer_name.strip() == "":
             customer_name = "Público General"
             
        header = (f"Ticket N°: {sale_record['ticket_number']}\n"
                  f"Fecha: {datetime.datetime.fromisoformat(sale_record['timestamp']).strftime('%Y-%m-%d %H:%M:%S')}\n"
                  f"Cliente: {customer_name}\n" # Incluir el nombre
                  f"Atendido por: {sale_record['user']}\n"
                  f"----------------------------------------\n")
        items_text = ""
        for item in sale_record['items']:
            # Mostrar precio efectivo (item['price'])
            line = f"{item['quantity']}x {item['name']} - ${item['price'] * item['quantity']:.2f}"
            # Opcional: Indicar si se aplicó precio mayorista
            if item.get('price') != item.get('regular_price'):
                 line += " (Mayorista)"
            items_text += line + "\n"
            
        footer = (f"----------------------------------------\n"
                  f"Metodo de Pago: {sale_record['payment_method']}\n"
                  f"TOTAL: ${sale_record['total']:.2f}\n\n"
              
                  f"Este ticket de compra NO ES UN COMPROBANTE FISCAL.\n"
                  f"Para Devoluciones solamente se cuenta con 7\n"
                  f"días naturales a partir de la fecha de compra.\n")
        return header + items_text + footer
    # -----------------------------------------------------------------

    def open_menu(self): MenuWindow(self)

# --- CLASE RESTAURADA (SIN IMPRESIÓN TÉRMICA) ---
class ShippingOptionsWindow(ctk.CTkToplevel):
    def __init__(self, master, sale_record):
    
        super().__init__(master)
        # ELIMINADO: self.geometry("450x200")
        self.master_screen = master
        self.sale_record = sale_record
        self.title("Método de Envío del Ticket")
        self.transient(master)
        self.grab_set()
        
        ctk.CTkLabel(self, text="Seleccione el método de envío del ticket", font=ctk.CTkFont(size=16)).pack(pady=20, padx=20)
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(pady=10)
        
        # BOTÓN 1: Imprimir/Guardar Ticket en PDF
        ctk.CTkButton(button_frame, text="Imprimir Ticket en PDF", command=self.print_to_pdf, height=40).pack(side="left", padx=10)
        
        # BOTÓN 2: Enviar por Correo Electrónico
        ctk.CTkButton(button_frame, text="Enviar por Correo Electrónico", command=self.send_by_email, height=40).pack(side="left", padx=10)
    
    def print_to_pdf(self):
        ticket_text = self.master_screen.generate_ticket_text(self.sale_record)
       
        ticket_filename = f"tickets/venta_{self.sale_record['ticket_number']}.pdf"
        os.makedirs("tickets", exist_ok=True)
        create_pdf_with_logo("Boutique El Impulso", "Ticket de Venta", ticket_text, ticket_filename)
        messagebox.showinfo("Éxito", f"Ticket guardado como:\n{ticket_filename}")
        self.master_screen.reset_sale_screen()
        self.destroy()
        
    def send_by_email(self): EmailTicketWindow(self, self.sale_record, self.master_screen)


class EmailTicketWindow(ctk.CTkToplevel):
    def __init__(self, master, sale_record, main_screen):
        super().__init__(master)
        # ELIMINADO: self.geometry("400x300")
        self.master = master
        self.sale_record = sale_record
        self.main_screen = main_screen
        self.title("Enviar Ticket por Correo")
        self.transient(master)
        self.grab_set()
        
        ctk.CTkLabel(self, text="Correo Electrónico del Cliente:", font=ctk.CTkFont(size=14)).pack(pady=(20, 5))
        self.email_entry = ctk.CTkEntry(self, placeholder_text="ejemplo@correo.com", width=300)
        self.email_entry.pack()
        button_frame = ctk.CTkFrame(self, fg_color="transparent")
        button_frame.pack(pady=20)
        
        self.send_button = ctk.CTkButton(button_frame, text="Enviar Ticket", command=lambda: self.handle_send_email(False))
        self.send_button.pack(side="left", padx=10, ipady=5)
        self.resend_button = ctk.CTkButton(button_frame, text="Reenviar Ticket", command=lambda: self.handle_send_email(True))
        self.resend_button.pack(side="left", padx=10, ipady=5)
        self.status_label = ctk.CTkLabel(self, text="", text_color="gray")
        self.status_label.pack(pady=(0, 10))
        
    def handle_send_email(self, is_resend=False):
        email_address = self.email_entry.get().strip()
        if not email_address:
     
            messagebox.showerror("Error", "Por favor, ingrese una dirección de correo.", parent=self)
            return
        self.send_button.configure(state="disabled", text="Enviando...")
        self.resend_button.configure(state="disabled")
        self.status_label.configure(text="Generando ticket y conectando...")
        self.update_idletasks()
        safe_timestamp = str(self.sale_record['ticket_number'])
        ticket_filename = f"temp_ticket_{safe_timestamp}.pdf"
        try:
            ticket_text = self.main_screen.generate_ticket_text(self.sale_record)
            create_pdf_with_logo("Boutique El Impulso", "Ticket de Venta", ticket_text, ticket_filename)
   
            config = read_db("email")
            if config["sender_email"] == "tu_correo@gmail.com":
                 messagebox.showerror("Configuración Requerida", "Debe configurar 'email_config.json' antes de enviar correos.", parent=self)
                 return
            self.send_email_logic(recipient=email_address, subject="Su Ticket de Compra - Boutique El Impulso", body="¡Hola!\n\nAdjunto encontrará su ticket de compra.\n\nGracias por su preferencia.", attachment_path=ticket_filename, config=config)
            messagebox.showinfo("Éxito", "Ticket enviado correctamente.")
            self.main_screen.reset_sale_screen()
            self.master.destroy()
            self.destroy()
        except FileNotFoundError: messagebox.showerror("Error de Configuración", "No se encontró 'email_config.json'.", parent=self)
        except smtplib.SMTPAuthenticationError: messagebox.showerror("Error de Autenticación", "La combinación de correo y contraseña de aplicación es incorrecta. Verifique 'email_config.json'.", parent=self)
        except (socket.gaierror, ConnectionRefusedError): messagebox.showerror("Error de Conexión", "No se pudo conectar al servidor de correo. Verifique su conexión a internet.", parent=self)
        except Exception as e: messagebox.showerror("Error de Envío", f"Ocurrió un error inesperado:\n{e}", parent=self)
        finally:
   
            self.send_button.configure(state="normal", text="Enviar Ticket")
            self.resend_button.configure(state="normal")
            self.status_label.configure(text="")
            if os.path.exists(ticket_filename): os.remove(ticket_filename)
            
    def send_email_logic(self, recipient, subject, body, attachment_path, config):
        msg = MIMEMultipart()
        msg['From'] = f"Boutique El Impulso <{config['sender_email']}>"
        msg['To'] = recipient
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))
        with open(attachment_path, "rb") as attachment:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", f"attachment; filename=ticket_compra.pdf")
        msg.attach(part)
        server = smtplib.SMTP(config['smtp_server'], config['smtp_port'])
        server.starttls()
        server.login(config['sender_email'], config['sender_password'])
        server.sendmail(config['sender_email'], recipient, msg.as_string())
        server.quit()

class PaymentWindow(ctk.CTkToplevel):
    def __init__(self, master, total_amount):
        super().__init__(master)
        # ELIMINADO: self.geometry("400x350")
        self.master_screen = master
        self.total_amount = total_amount
        self.title("Método de Pago")
        self.transient(master)
        self.grab_set()
        
        ctk.CTkLabel(self, text=f"Total a Pagar: ${self.total_amount:.2f}", font=ctk.CTkFont(size=22, weight="bold")).pack(pady=20)
        self.payment_method = ctk.StringVar(value="Efectivo")
        ctk.CTkOptionMenu(self, variable=self.payment_method, values=["Efectivo", "Tarjeta Bancaria", "Transferencia"], command=self.update_payment_fields).pack(pady=10)
        self.fields_frame = ctk.CTkFrame(self)
        self.fields_frame.pack(pady=10, padx=20, fill="x")
        self.update_payment_fields()
        
    def update_payment_fields(self, *args):
        for widget in self.fields_frame.winfo_children(): widget.destroy()
        if (method := self.payment_method.get()) == "Efectivo":
            ctk.CTkLabel(self.fields_frame, text="Monto Recibido:").pack(pady=5)
            self.amount_received_entry = ctk.CTkEntry(self.fields_frame, justify="center")
            self.amount_received_entry.pack()
            self.amount_received_entry.bind("<KeyRelease>", self.calculate_change)
            self.change_label = ctk.CTkLabel(self.fields_frame, text="Cambio: $0.00", font=ctk.CTkFont(size=16))
            self.change_label.pack(pady=10)
        else:
            ctk.CTkLabel(self.fields_frame, text="Folio de Transacción:").pack(pady=5)
            self.folio_entry = ctk.CTkEntry(self.fields_frame, justify="center")
            self.folio_entry.pack()
            
        ctk.CTkButton(self, text="Confirmar Pago", command=self.process_payment).pack(pady=20)
        
    def calculate_change(self, event=None):
        try: 
            self.change_label.configure(text=f"Cambio: ${float(self.amount_received_entry.get()) - self.total_amount:.2f}")
        except (ValueError, TypeError): 
            self.change_label.configure(text="Cambio: $0.00")
            
    def process_payment(self):
        method, details = self.payment_method.get(), {}
        if method == "Efectivo":
            try:
               
                if (received := float(self.amount_received_entry.get())) < self.total_amount: messagebox.showerror("Error", "El monto recibido es menor al total."); return
                details = {"received": received, "change": received - self.total_amount}
            except ValueError: messagebox.showerror("Error", "Ingrese un monto válido."); return
        else:
            if not (folio := self.folio_entry.get().strip()): messagebox.showerror("Error", "El folio es obligatorio."); return
            details = {"folio": folio}
            
        self.master_screen.finalize_sale(method, self.total_amount, details)
        self.destroy()

# --- CLASE MENU WINDOW MODIFICADA CON BOTÓN DE HISTORIAL Y CORRECCIÓN DE INDENTACIÓN ---
class MenuWindow(ctk.CTkToplevel):
    def __init__(self, master):
        # AÑADIR PROTOCOLO DE CIERRE Y COLOR DE FONDO FORZADO (para estabilidad)
        super().__init__(master, fg_color=("White", "gray20")) 
        # ELIMINADO: self.geometry("300x500")
        self.master_app = master.controller # CORRECCIÓN DE ATTRIBUTE ERROR
        
        # Indentación corregida y explícita para evitar IndentationError
        self.title("Menú de Opciones")
        self.transient(master)
        self.grab_set() 
        
        ctk.CTkLabel(self, text="Opciones del Sistema", font=ctk.CTkFont(size=18, weight="bold")).pack(pady=20)
        
        # Se añade el botón "Historial de Ventas"
        buttons_info = [
            ("Historial de Ventas", self.open_sales_history), 
            ("Ajustes del programa", self.open_settings), 
            ("Devolución", self.open_return_window), 
      
            ("Dar de alta/Baja usuario", self.open_user_manager), 
            ("Administrar inventario", self.open_inventory_manager), 
            ("Corte de caja", self.open_cash_count)
        ]
        
        for text, command in buttons_info: 
            ctk.CTkButton(self, text=text, command=command, height=40).pack(pady=10, padx=20, fill="x")
        
        self.protocol("WM_DELETE_WINDOW", self.on_closing) # Añadir protocolo de cierre

    def on_closing(self):
      
        self.grab_release()
        self.destroy()
        
    # --- CHECK DE ROL MEJORADO PARA ROBUSTEZ ---
    def check_admin_role(self):
        if not self.master_app.current_user:
             messagebox.showerror("Acceso Denegado", "Debe iniciar sesión primero.")
             return False
             
        # Normalizar la cadena para comparación (quita espacios y pone minúsculas)
        user_role = self.master_app.current_user_role.strip().lower() 
        
        if user_role != "administrador": 
             messagebox.showerror("Acceso Denegado", "Opción solo para administradores.")
             return False
        return True
    # -------------------------------------------
    
    # NUEVO MÉTODO PARA ABRIR EL HISTORIAL (Solo Administrador)
    def open_sales_history(self):
        if self.check_admin_role():
            SalesHistoryWindow(self)
            
    def open_settings(self): SettingsWindow(self)
    def open_return_window(self): ReturnWindow(self)
    def open_user_manager(self): 
        if self.check_admin_role(): UserManagerWindow(self)
    def open_inventory_manager(self):
   
        if self.check_admin_role(): InventoryManagerWindow(self)
    def open_cash_count(self): CashCountWindow(self)

class ReturnWindow(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master)
        # ELIMINADO: self.geometry("600x500")
        self.title("Gestión de Devoluciones")
        self.transient(master)
        self.grab_set()
        
        self.found_sale = None
        top_frame = ctk.CTkFrame(self)
        top_frame.pack(pady=10, padx=10, fill="x")
        ctk.CTkLabel(top_frame, text="Ingrese Número de Ticket:").pack(side="left", padx=5)
        self.ticket_entry = ctk.CTkEntry(top_frame, placeholder_text="Ej: 123")
        self.ticket_entry.pack(side="left", padx=5, fill="x", expand=True)
        self.ticket_entry.bind("<Return>", lambda e: self.search_ticket())
        ctk.CTkButton(top_frame, text="Buscar Ticket", command=self.search_ticket).pack(side="left", padx=5)
        info_frame = ctk.CTkFrame(self, fg_color="transparent")
        info_frame.pack(pady=10, padx=10, fill="both", expand=True)
        self.info_text = ctk.CTkTextbox(info_frame, state="disabled", font=("Courier", 12))
        self.info_text.pack(fill="both", expand=True)
        self.return_button = ctk.CTkButton(self, text="Realizar Devolución", command=self.process_return, state="disabled")
        self.return_button.pack(pady=10, padx=10)
        
        self.protocol("WM_DELETE_WINDOW", self.on_closing) # Añadir protocolo de cierre

    def on_closing(self):
        self.grab_release()
       
        self.destroy()
        
    def search_ticket(self):
        self.info_text.configure(state="normal")
        self.info_text.delete("1.0", END)
        self.found_sale = None
        self.return_button.configure(state="disabled")
        try:
            ticket_number = int(self.ticket_entry.get())
        except ValueError:
            messagebox.showerror("Error", "El número de ticket debe ser un número válido.", parent=self)
            return
        sales = read_db("sales")
        sale_found = next((s for s in sales if s.get("ticket_number") == ticket_number), None)
        if not sale_found:
            self.info_text.insert("1.0", f"No se encontró ninguna venta con el ticket N° {ticket_number}.")
            self.info_text.configure(state="disabled")
            return
 
        self.found_sale = sale_found
        sale_date = datetime.datetime.fromisoformat(sale_found["timestamp"])
        days_since_purchase = (datetime.datetime.now() - sale_date).days
        
        # Mostrar el nombre del cliente
        customer_name = sale_found.get('customer_name')
        if not customer_name or customer_name.strip() == "":
            customer_name = "Público General"
            
        info = (f"Ticket N°: {sale_found['ticket_number']}\n"
            f"Fecha de Compra: {sale_date.strftime('%Y-%m-%d %H:%M')}\n"
            f"Días desde la compra: {days_since_purchase}\n"
            f"Cliente: {customer_name}\n"
            f"Total: ${sale_found['total']:.2f}\n"
            f"Estado: {sale_found['status']}\n"
            f"----------------------------------------\n")
        for item in sale_found["items"]:
            info += f"{item['quantity']}x {item['name']} - ${item['price'] * item['quantity']:.2f}\n"
        self.info_text.insert("1.0", info)
        if sale_found['status'] == 'DEVUELTA':
            self.info_text.insert(END, "\nERROR: Este ticket ya ha sido devuelto.")
    
        elif days_since_purchase > 7:
            self.info_text.insert(END, f"\nERROR: Han pasado más de 7 días. No se puede realizar la devolución.")
        else:
            self.return_button.configure(state="normal")
        self.info_text.configure(state="disabled")
        
    def process_return(self):
        if not self.found_sale: return
        if not messagebox.askyesno("Confirmar Devolución", "¿Está seguro de realizar la devolución de este ticket?", parent=self):
            return
        inventory = read_db("inventory")
        
        for item in self.found_sale["items"]:
            if item["sku"] in inventory:
                # Al devolver, se devuelve la cantidad original.
                inventory[item["sku"]]["quantity"] += item["quantity"]
        write_db("inventory", inventory)
        sales = read_db("sales")
        for sale in sales:
            if sale.get("ticket_number") == self.found_sale["ticket_number"]:
                sale["status"] = "DEVUELTA"
 
                break
        write_db("sales", sales)
        messagebox.showinfo("Éxito", "Devolución procesada correctamente.\nEl inventario y el registro de ventas han sido actualizados.", parent=self)
        self.destroy()

# --- CLASE SETTINGS WINDOW MODIFICADA PARA ESTABILIDAD Y SIN OPCIONES EXTRA ---
class SettingsWindow(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master)
        # ELIMINADO: self.geometry("400x450")
        self.title("Ajustes del Programa")
        self.transient(master)
        self.grab_set() # Geometry ajustada
        
        ctk.CTkLabel(self, text="Ajustes", font=ctk.CTkFont(size=18, weight="bold")).pack(pady=10)
        self.config = read_db("config")
        
        # --- APARIENCIA ---
        appearance_frame = ctk.CTkFrame(self)
        appearance_frame.pack(pady=10, padx=10, fill="x")
        ctk.CTkLabel(appearance_frame, text="Modo de Apariencia:").pack(anchor="w", padx=10)
        self.appearance_mode_var = ctk.StringVar(value=self.config.get("appearance_mode", "dark"))
        ctk.CTkOptionMenu(appearance_frame, variable=self.appearance_mode_var, values=["light", "dark", "system"], command=self.change_appearance).pack(fill="x", padx=10, pady=5)
        
        # --- TEMA DE COLOR (Solo temas base estables) ---
        ctk.CTkLabel(appearance_frame, text="Tema de Color:").pack(anchor="w", padx=10, pady=(10,0))
        self.color_theme_var = ctk.StringVar(value=self.config.get("color_theme", "blue"))
        # Opciones de 
        # tema base estables
        ctk.CTkOptionMenu(appearance_frame, variable=self.color_theme_var, values=["blue", "dark-blue", "green"], command=self.change_theme).pack(fill="x", padx=10, pady=5)
        
        # --- MANTENIMIENTO ---
        program_frame = ctk.CTkFrame(self)
        program_frame.pack(pady=10, padx=10, fill="x")
        ctk.CTkLabel(program_frame, text="Mantenimiento y Pruebas:").pack(anchor="w", padx=10)
        ctk.CTkButton(program_frame, text="Probar Conexión de Correo", command=self.test_email_connection).pack(fill="x", padx=10, pady=10)
        ctk.CTkButton(program_frame, text="Restablecer Programa", fg_color="#c0392b", hover_color="#e74c3c", command=self.reset_program).pack(fill="x", padx=10, pady=10)
        
        # BOTÓN DE CERRAR
        ctk.CTkButton(self, text="Cerrar Ajustes", command=self.on_closing).pack(pady=10)
        
        ctk.CTkLabel(self, text="Nota: Los cambios de apariencia requieren reiniciar la aplicación.", 
                     justify="center").pack(pady=10)
        
        self.protocol("WM_DELETE_WINDOW", self.on_closing) # Añadir protocolo de cierre

    # MÉTODO PARA CIERRE SEGURO
    def on_closing(self):
        self.grab_release()
        self.destroy()

    # MODIFICADO: Solo guarda y notifica (Estabilidad)
    def change_appearance(self, mode): 
        messagebox.showinfo("Cambio de Apariencia", "El modo se aplicará al reiniciar la aplicación.")
        self.config["appearance_mode"] = mode
        write_db("config", self.config)

    # MODIFICADO: Solo guarda y notifica (Estabilidad)
    def change_theme(self, theme): 
        messagebox.showinfo("Cambio de Tema", "El tema se aplicará al reiniciar la aplicación.")
        self.config["color_theme"] = theme
        write_db("config", self.config)
        
    def reset_program(self):
        if messagebox.askyesno("Confirmar", "¡ADVERTENCIA!\nEsto borrará TODOS los datos.\n¿Está seguro?"):
            for file in DB_FILES.values():
                if os.path.exists(file): os.remove(file)
            messagebox.showinfo("Éxito", "Programa restablecido. Se reiniciará."); # Usar execv para reemplazar el proceso actual y reiniciar
            os.execv(sys.executable, ['python'] + sys.argv)
            
    def test_email_connection(self):
        try:
            config = read_db("email")
            if config["sender_email"] == "tu_correo@gmail.com":
                 messagebox.showerror("Configuración Requerida", "Debe configurar 'email_config.json' antes de probar.", parent=self); return
            with smtplib.SMTP(config['smtp_server'], config['smtp_port']) as server:
                server.starttls()
                server.login(config['sender_email'], config['sender_password'])
            messagebox.showinfo("Éxito", "¡Conexión exitosa!\nEl servidor de correo respondió correctamente.", parent=self)
        except smtplib.SMTPAuthenticationError: messagebox.showerror("Error de Autenticación", "Correo o contraseña de aplicación incorrectos.", parent=self)
        except (socket.gaierror, ConnectionRefusedError): messagebox.showerror("Error de Conexión", "No se pudo conectar al servidor. Verifique internet y el nombre del servidor.", parent=self)
        except Exception as e: messagebox.showerror("Error", f"Ocurrió un error inesperado:\n{e}", parent=self)

class UserManagerWindow(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master)
        # ELIMINADO: self.geometry("600x400")
 
        self.title("Administración de Usuarios")
        self.transient(master)
        self.grab_set()
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
        list_frame = ctk.CTkFrame(self)
        list_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        list_frame.grid_columnconfigure(0, weight=1)
        list_frame.grid_rowconfigure(0, weight=1)
        
        self.user_listbox = Listbox(list_frame, bg="#2b2b2b", fg="white", border=0, selectbackground="#1f6aa5")
        self.user_listbox.grid(row=0, column=0, sticky="nsew")
        
        actions_frame = ctk.CTkFrame(self)
        actions_frame.grid(row=0, column=1, sticky="ns", padx=10, pady=10)
        ctk.CTkButton(actions_frame, text="Añadir Usuario", command=self.add_user).pack(pady=5, fill="x")
        ctk.CTkButton(actions_frame, text="Eliminar Usuario", command=self.remove_user).pack(pady=5, fill="x")
        ctk.CTkButton(actions_frame, text="Cambiar Contraseña", command=self.change_password).pack(pady=5, fill="x")
        self.refresh_user_list()
        
    def refresh_user_list(self):
        self.user_listbox.delete(0, END)
        users = read_db("users")
        for username, data in users.items():
            # Muestra Nombre Completo y Rol, junto con el Usuario (EID)
            display_name = data.get("full_name", username)
            self.user_listbox.insert(END, f"{display_name} ({data['role']}) - Usuario: {username}")

    def add_user(self):
        # 1. Solicitar datos personales
        full_name = simpledialog.askstring("Añadir Usuario", "Nombre completo:", parent=self)
        if not full_name: return
        
        phone = simpledialog.askstring("Añadir Usuario", "Número telefónico (Opcional):", parent=self)
        if not phone: phone = "N/A"
        
        email = simpledialog.askstring("Añadir Usuario", "Correo electrónico (Opcional):", parent=self)
        if not email: email = "N/A"

        # 2. Generar usuario (Número de Empleado)
        new_username = get_next_employee_id()
        
        # 3. Mostrar el usuario generado
        messagebox.showinfo("Usuario Generado", f"El número de empleado (usuario) asignado es: {new_username}", parent=self)

        # 4. Solicitar el rol
        role = simpledialog.askstring("Añadir Usuario", f"Rol para '{full_name}' (administrador/vendedor):", parent=self)
        if not (role and role.lower() in ["administrador", "vendedor"]):
             messagebox.showerror("Error", "Rol no válido. Debe ser 'administrador' o 'vendedor'.", parent=self)
             return

        # 5. Asignar la contraseña
        password = simpledialog.askstring("Añadir Usuario", f"Contraseña para '{new_username}':", parent=self, show="*")
        if not password: return

        # 6. Guardar en la base de datos
        users = read_db("users")
        users[new_username] = {
            "password": password, 
            "role": role.lower(), 
            "full_name": full_name,
            "phone": phone,
            "email": email
        }
        write_db("users", users)
        
        messagebox.showinfo("Éxito", f"Usuario '{new_username}' añadido correctamente.", parent=self)
        self.refresh_user_list()
             
    def remove_user(self):
        selected = self.user_listbox.curselection()
        if not selected: messagebox.showwarning("Sin Selección", "Seleccione un usuario para eliminar.", parent=self); return
        
        # Parsear el username (EID) de la cadena: "Nombre (rol) - Usuario: E###"
        selected_text = self.user_listbox.get(selected[0])
        try:
            username = selected_text.split("Usuario: ")[-1]
        except:
            # Fallback simple si el formato de la lista es diferente (seguro en este caso)
            username = selected_text.split(" ")[0]
            
        if username == "E001": messagebox.showerror("Error", "No se puede eliminar al usuario administrador principal (E001).", parent=self); return
        if messagebox.askyesno("Confirmar", f"¿Seguro que desea eliminar al usuario '{username}'?", parent=self):
           
            users = read_db("users")
            if username in users: 
                del users[username]
                write_db("users", users)
                self.refresh_user_list()
            else:
                 messagebox.showerror("Error", "No se pudo encontrar el usuario en la base de datos.", parent=self)
            
    def change_password(self):
        selected = self.user_listbox.curselection()
        if not selected: messagebox.showwarning("Sin Selección", "Seleccione un usuario.", parent=self); return
        
        # Parsear el username (EID) de la cadena: "Nombre (rol) - Usuario: E###"
        selected_text = self.user_listbox.get(selected[0])
        try:
            username = selected_text.split("Usuario: ")[-1]
        except:
            username = selected_text.split(" ")[0]
            
        new_password = simpledialog.askstring("Nueva Contraseña", f"Ingrese la nueva contraseña para '{username}':", parent=self, show="*")
        if new_password:
            users = read_db("users")
            if username in users:
                users[username]["password"] = new_password
                write_db("users", users)
                messagebox.showinfo("Éxito", f"Contraseña de '{username}' actualizada.", parent=self)
            else:
                messagebox.showerror("Error", "No se pudo encontrar el usuario en la base de datos.", parent=self)

# --- VENTANA DE INVENTARIO MODIFICADA (con ajuste de stock y precios mayoristas) ---
class InventoryManagerWindow(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master)
        # ELIMINADO: self.geometry("900x600")
        self.title("Administración de Inventario")
        self.transient(master)
        self.grab_set() 
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        top_frame = ctk.CTkFrame(self)
        top_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
        
        ctk.CTkLabel(top_frame, text="SKU:").pack(side="left", padx=5)
        self.sku_entry = ctk.CTkEntry(top_frame, placeholder_text="Escanear o ingresar SKU")
        self.sku_entry.pack(side="left", padx=5, fill="x", expand=True)
        
        ctk.CTkLabel(top_frame, text="Nombre:").pack(side="left", padx=5)
        self.name_entry = ctk.CTkEntry(top_frame, placeholder_text="Nombre del producto")
        self.name_entry.pack(side="left", padx=5, fill="x", expand=True)
        
        ctk.CTkLabel(top_frame, text="Precio:").pack(side="left", padx=5)
        self.price_entry = ctk.CTkEntry(top_frame, placeholder_text="0.00", width=80)
        self.price_entry.pack(side="left", padx=5)
        
        # NUEVO CAMBIO: Precio Mayorista
        ctk.CTkLabel(top_frame, text="P. Mayorista:").pack(side="left", padx=5)
        self.wholesale_price_entry = ctk.CTkEntry(top_frame, placeholder_text="0.00", width=100) 
        self.wholesale_price_entry.pack(side="left", padx=5)
        # --------------------------------
        
        ctk.CTkLabel(top_frame, text="Cantidad:").pack(side="left", padx=5)
        self.quantity_entry = ctk.CTkEntry(top_frame, placeholder_text="0", width=80)
        self.quantity_entry.pack(side="left", padx=5)
        
        # Botón renombrado a "Añadir Producto" (no suma, reemplaza/crea)
        ctk.CTkButton(top_frame, text="Añadir Producto", command=self.add_update_item, width=140).pack(side="left", padx=10)
        
        # --- NUEVOS BINDINGS DEL TECLADO ---
        # BINDINGS: Permite agregar/actualizar presionando Enter en cualquier campo
        self.sku_entry.bind("<Return>", lambda e: self.add_update_item())
        self.name_entry.bind("<Return>", lambda e: self.add_update_item())
        self.price_entry.bind("<Return>", lambda e: self.add_update_item())
        self.wholesale_price_entry.bind("<Return>", lambda e: self.add_update_item())
        self.quantity_entry.bind("<Return>", lambda e: self.add_update_item())
        # -----------------------------------

        tree_frame = ctk.CTkFrame(self)
        tree_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        tree_frame.grid_columnconfigure(0, weight=1)
        tree_frame.grid_rowconfigure(0, weight=1)
        
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview", background="#2b2b2b", foreground="white", fieldbackground="#2b2b2b", borderwidth=0)
        style.map('Treeview', background=[('selected', '#1f6aa5')])
        
        # CAMBIO: Columnas del Treeview
        self.tree = ttk.Treeview(tree_frame, columns=("SKU", "Nombre", "Precio", "P. Mayorista", "Cantidad"), show="headings")
        self.tree.heading("SKU", text="SKU")
        self.tree.heading("Nombre", text="Nombre")
        self.tree.heading("Precio", text="Precio")
        self.tree.heading("P. Mayorista", text="P. Mayorista") # Nueva columna
        self.tree.heading("Cantidad", text="Cantidad")
        self.tree.grid(row=0, column=0, sticky="nsew")
        
        bottom_frame = ctk.CTkFrame(self)
        bottom_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=10)
        
        # BOTÓN NUEVO: Editar Precios
        ctk.CTkButton(bottom_frame, text="Editar Precios", command=self.edit_prices, fg_color="#3498db", hover_color="#2980b9").pack(side="left", padx=10)
        
        ctk.CTkButton(bottom_frame, text="Ajustar Stock", command=self.adjust_stock, fg_color="#3498db", hover_color="#2980b9").pack(side="left", padx=10)
        ctk.CTkButton(bottom_frame, text="Guardar como PDF", command=self.save_pdf).pack(side="left", padx=10)
        ctk.CTkButton(bottom_frame, text="Editar Descripción", command=self.edit_item_description).pack(side="left", padx=10)
        ctk.CTkButton(bottom_frame, text="Eliminar Producto", command=self.remove_item, fg_color="#c0392b", hover_color="#e74c3c").pack(side="left", padx=10)
        self.refresh_inventory_list()

    def refresh_inventory_list(self):
        for i in self.tree.get_children(): self.tree.delete(i)
        inventory = read_db("inventory")
        for sku, data in sorted(inventory.items()): # Ordenado por SKU
            # CAMBIO: Leer el precio mayorista
            wholesale_price = data.get("wholesale_price", 0.0) 
            self.tree.insert("", "end", iid=sku, values=(sku, data["name"], f"${data['price']:.2f}", f"${wholesale_price:.2f}", data["quantity"]))
    
    def add_update_item(self):
        sku = self.sku_entry.get().strip().upper()
        name = self.name_entry.get().strip()
        price = self.price_entry.get().strip()
        wholesale_price = self.wholesale_price_entry.get().strip() # NUEVO
        quantity = self.quantity_entry.get().strip()
        
        if not all([sku, name, price, wholesale_price, quantity]): 
            messagebox.showerror("Error", "Todos los campos son obligatorios.", parent=self);
            return

        try: 
            # --- VALIDACIÓN DE DATOS ---
            price_val = float(price)
            quant_val = int(quantity)
            wholesale_price_val = float(wholesale_price)
            
            if wholesale_price_val > price_val:
                messagebox.showerror("Error", "El precio mayorista no puede ser mayor que el precio normal.", parent=self)
                return
            if price_val < 0 or wholesale_price_val < 0:
                 messagebox.showerror("Error", "Los precios no pueden ser negativos.", parent=self)
                 return
            if quant_val < 0:
                messagebox.showerror("Error", "La cantidad debe ser un número positivo.", parent=self)
                return

            # --- LÓGICA DE ACTUALIZACIÓN ---
            inventory = read_db("inventory")
            
            item_data = {"name": name, "price": price_val, "quantity": quant_val, "wholesale_price": wholesale_price_val}
            
            if sku in inventory:
                inventory[sku] = item_data
                messagebox.showinfo("Inventario Actualizado", f"Producto {sku} actualizado completamente.", parent=self)
    
            else:
                inventory[sku] = item_data
                messagebox.showinfo("Inventario Actualizado", f"Producto nuevo ({sku}) añadido.", parent=self)

            write_db("inventory", inventory)
            self.refresh_inventory_list()
            
            # Limpiar campos después del éxito
            self.sku_entry.delete(0, END)
            self.name_entry.delete(0, END)
            self.price_entry.delete(0, END)
            self.wholesale_price_entry.delete(0, END)
            self.quantity_entry.delete(0, END)
            self.sku_entry.focus()
        
        except ValueError:
            # Captura errores de conversión float/int
            messagebox.showerror("Error", "Precio, Precio Mayorista y Cantidad deben ser números válidos.", parent=self)
            return
        
        except Exception as e:
            # Captura cualquier otro error de ejecución (para diagnóstico)
            messagebox.showerror("Error Crítico de Inventario", f"Ocurrió un error inesperado al guardar: {e}", parent=self)
    
    # NUEVO MÉTODO: Editar Precios
    def edit_prices(self):
        selected_item = self.tree.focus() 
        if not selected_item:
            messagebox.showwarning("Sin Selección", "Por favor, seleccione un producto de la lista para editar precios.", parent=self)
            return
        
        sku = selected_item 
        inventory = read_db("inventory")
        if sku not in inventory:
             messagebox.showerror("Error", "El producto no se encontró en la base de datos.", parent=self)
             return

        item = inventory[sku]
        
        new_price_str = simpledialog.askstring("Editar Precios", f"Ingrese el nuevo Precio Normal para el producto SKU: {sku}\n(Actual: ${item['price']:.2f})", 
                                               initialvalue=str(item['price']), parent=self)
        if new_price_str is None: return

        # Usar 0.0 como valor inicial si no existe (para compatibilidad)
        current_wholesale = item.get('wholesale_price', 0.0) 
        new_wholesale_price_str = simpledialog.askstring("Editar Precios", f"Ingrese el nuevo Precio Mayorista para el producto SKU: {sku}\n(Actual: ${current_wholesale:.2f})", 
                                                         initialvalue=str(current_wholesale), parent=self)
        if new_wholesale_price_str is None: return

        try:
            new_price = float(new_price_str.strip())
            new_wholesale_price = float(new_wholesale_price_str.strip())
            
            if new_wholesale_price > new_price:
                messagebox.showerror("Error", "El precio mayorista no puede ser mayor que el precio normal.", parent=self)
                return
            if new_price < 0 or new_wholesale_price < 0:
                 messagebox.showerror("Error", "Los precios no pueden ser negativos.", parent=self)
                 return
                 
        except ValueError:
            messagebox.showerror("Error", "Los precios deben ser números válidos.", parent=self)
            return

        item['price'] = new_price
        item['wholesale_price'] = new_wholesale_price
        
        write_db("inventory", inventory)
        self.refresh_inventory_list()
        messagebox.showinfo("Éxito", f"Precios de {sku} actualizados.", parent=self)
    
    def adjust_stock(self):
        selected_item = self.tree.focus() 
        if not selected_item:
            messagebox.showwarning("Sin Selección", "Por favor, seleccione un producto de la lista para ajustar el stock.", parent=self)
            return
       
        
        sku = selected_item # CORRECCIÓN: El item ID es el SKU
        item_details = self.tree.item(selected_item)
        current_quantity = item_details['values'][4] # Columna 4 es Cantidad (0-indexed)

        new_quantity_str = simpledialog.askstring(
            "Ajustar Stock", 
            f"Ingrese la nueva cantidad TOTAL en inventario para el producto SKU: {sku}\n(Stock actual: {current_quantity})", 
           
            parent=self
        )

        if new_quantity_str is not None:
            try:
                new_quantity = int(new_quantity_str.strip())
                if new_quantity < 0:
                    messagebox.showerror("Error", "La cantidad debe ser un número entero positivo o cero.", parent=self)
                    return
            except ValueError:
                messagebox.showerror("Error", "La cantidad debe ser un número entero válido.", parent=self)
                return

            inventory = read_db("inventory")
           
            if sku in inventory:
                inventory[sku]['quantity'] = new_quantity
                write_db("inventory", inventory)
                self.refresh_inventory_list()
                messagebox.showinfo("Éxito", f"Stock de {sku} ajustado a {new_quantity}.", parent=self)
            else:
          
                messagebox.showerror("Error", "El producto no se encontró en la base de datos.", parent=self)

    # CORRECCIÓN DE ESTABILIDAD: Usa el item ID como SKU
    def edit_item_description(self):
        selected_item = self.tree.focus() 
        if not selected_item:
            messagebox.showwarning("Sin Selección", "Por favor, seleccione un producto de la lista para editar.", parent=self)
            return
        
 
        sku = selected_item 
        item_details = self.tree.item(selected_item)
        current_name = item_details['values'][1]

        new_name = simpledialog.askstring("Editar Descripción", f"Ingrese el nuevo nombre para el producto SKU: {sku}", initialvalue=current_name, parent=self)

        if new_name and new_name.strip() != "":
            inventory = read_db("inventory")
            if sku in inventory:
     
                inventory[sku]['name'] = new_name.strip()
                write_db("inventory", inventory)
                self.refresh_inventory_list()
                messagebox.showinfo("Éxito", "Descripción del producto actualizada.", parent=self)
        elif new_name is not None: # Si el usuario borra el texto y presiona OK
           
            messagebox.showerror("Error", "La descripción no puede estar vacía.", parent=self)

    # CORRECCIÓN DE ESTABILIDAD: Usa el item ID como SKU
    def remove_item(self):
        selected_item = self.tree.focus() 
        if not selected_item:
            messagebox.showwarning("Sin Selección", "Por favor, seleccione un producto de la lista para eliminar.", parent=self); return
            
     
        sku = selected_item 
        item_details = self.tree.item(selected_item)
        product_name = item_details['values'][1]
        
        if messagebox.askyesno("Confirmar Eliminación", f"¿Seguro que quieres eliminar al producto '{product_name}'?", parent=self):
            inventory = read_db("inventory")
            if sku in inventory:
                del inventory[sku]
  
                write_db("inventory", inventory)
                self.refresh_inventory_list()
                messagebox.showinfo("Éxito", "Producto eliminado correctamente.", parent=self)
            else:
                messagebox.showerror("Error", "El producto no se encontró en la base de datos.", parent=self)
    
    def save_pdf(self):
 
        inventory = read_db("inventory")
        content = f"{'SKU':<15}{'Nombre':<35}{'Precio':>10}{'P. Mayorista':>15}{'Cantidad':>10}\n"
        content += "-" * 85 + "\n"
        for sku, data in sorted(inventory.items()):
            wholesale_price = data.get("wholesale_price", 0.0)
            content += f"{sku:<15}{data['name']:<35}${data['price']:>9.2f}${wholesale_price:>14.2f}{data['quantity']:>10}\n"
        os.makedirs("reportes", exist_ok=True)
        filename = f"reportes/inventario_{datetime.datetime.now().strftime('%Y%m%d')}.pdf"
        create_pdf_with_logo("Boutique El Impulso", "Reporte de Inventario", content, filename, align='L')
      
        messagebox.showinfo("Éxito", f"Reporte guardado como {filename}", parent=self)

# --- CLASE AÑADIDA: HISTORIAL DE VENTAS ---
class SalesHistoryWindow(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master) 
        # ELIMINADO: self.geometry("1000x600")
        self.title("Historial de Ventas")
        self.transient(master)
        self.grab_set()
        
        # Configuración de Grid
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        # --- Frame de Filtros ---
        filter_frame = ctk.CTkFrame(self)
        filter_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
        filter_frame.grid_columnconfigure((1, 3), weight=1)

        ctk.CTkLabel(filter_frame, text="De:").grid(row=0, column=0, padx=5, pady=5)
        self.date_start_entry = ctk.CTkEntry(filter_frame, placeholder_text="YYYY-MM-DD")
        self.date_start_entry.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        
        ctk.CTkLabel(filter_frame, text="Hasta:").grid(row=0, column=2, padx=5, pady=5)
        self.date_end_entry = ctk.CTkEntry(filter_frame, placeholder_text="YYYY-MM-DD")
        self.date_end_entry.grid(row=0, column=3, padx=5, pady=5, sticky="ew")
        
        # Botones de Filtrado
        ctk.CTkButton(filter_frame, text="Buscar", command=self.filter_sales).grid(row=0, column=4, padx=5, pady=5)
        ctk.CTkButton(filter_frame, text="Ventas de Hoy", command=lambda: self.load_sales('today')).grid(row=0, column=5, padx=5, pady=5)
        ctk.CTkButton(filter_frame, text="Solo Ventas", command=lambda: self.load_sales('all', status_filter='COMPLETADA')).grid(row=1, column=4, padx=5, pady=5)
        ctk.CTkButton(filter_frame, text="Solo Devoluciones", command=lambda: self.load_sales('all', status_filter='DEVUELTA')).grid(row=1, column=5, padx=5, pady=5)
        ctk.CTkButton(filter_frame, text="Mostrar Todo", command=lambda: self.load_sales('all')).grid(row=0, column=6, padx=5, pady=5)


 
        # --- Treeview para la Lista de Ventas ---
        tree_frame = ctk.CTkFrame(self)
        tree_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)
        tree_frame.grid_columnconfigure(0, weight=1)
        tree_frame.grid_rowconfigure(0, weight=1)
        
        # Configuración del estilo Treeview para customtkinter
        style = ttk.Style()
        style.theme_use("default")
        style.configure("Treeview", background="#2b2b2b", foreground="white", fieldbackground="#2b2b2b", borderwidth=0)
        style.map('Treeview', background=[('selected', '#1f6aa5')])
        
        columns = ("Ticket", "Fecha", "Usuario", "Método Pago", "Total", "Estado")
        self.tree = ttk.Treeview(tree_frame, columns=columns, show="headings")
        
        for col in columns:
            self.tree.heading(col, text=col)
          
            self.tree.column(col, width=100, anchor='center')

        self.tree.column("Fecha", width=180, anchor='center')
        self.tree.column("Total", width=120, anchor='e')
        self.tree.column("Ticket", width=80, anchor='center')
        self.tree.column("Usuario", width=120, anchor='center')

        self.tree.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar
        tree_scrollbar = ctk.CTkScrollbar(tree_frame, command=self.tree.yview)
        tree_scrollbar.grid(row=0, column=1, sticky="ns")
        self.tree.configure(yscrollcommand=tree_scrollbar.set)
        
        # --- NUEVA FUNCIONALIDAD: ABIR DETALLES AL HACER CLIC ---
        self.tree.bind("<<TreeviewSelect>>", self.show_sale_details)

        self.load_sales('today') # Cargar ventas del día al abrir

    def load_sales(self, filter_type='all', start_date=None, end_date=None, status_filter='all'):
        sales = read_db("sales")
        self.tree.delete(*self.tree.get_children())
        
        filtered_sales = sales
        today = datetime.datetime.now().date()

        if filter_type == 'today':
        
            filtered_sales = [s for s in sales if datetime.datetime.fromisoformat(s['timestamp']).date() == today]
        
        elif start_date and end_date:
            try:
                start_dt = datetime.datetime.strptime(start_date, '%Y-%m-%d').date()
                # Sumar un día a la fecha final para incluir ventas de ese día
       
                end_dt = datetime.datetime.strptime(end_date, '%Y-%m-%d').date() + datetime.timedelta(days=1)
                
                filtered_sales = [
                    s for s in sales 
                    if start_dt <= datetime.datetime.fromisoformat(s['timestamp']).date() < end_dt
  
                ]
            except ValueError:
                messagebox.showerror("Error de Fecha", "Formato de fecha inválido. Use YYYY-MM-DD.")
                return

        # Aplicar filtro de estado (Ventas o Devoluciones)
        if status_filter != 'all':
             # FIX: Si el campo 'status' falta, por defecto se considera 'COMPLETADA' para evitar KeyError.
             filtered_sales = [s for s in filtered_sales if s.get("status", "COMPLETADA") == status_filter]


        if not filtered_sales:
            self.tree.insert("", "end", values=("", "No hay ventas en este rango.", "", "", "", ""), tags=('no_sales',))
            self.tree.tag_configure('no_sales', foreground='gray')
            return

        for sale in sorted(filtered_sales, key=lambda s: s['timestamp'], reverse=True):
            
            # FIX: Obtener el estado de forma segura (para la visualización y el tag)
            sale_status = sale.get('status', 'COMPLETADA')
            
            sale_date = datetime.datetime.fromisoformat(sale['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            values = (
                sale['ticket_number'],
                sale_date,
                sale['user'],
                sale['payment_method'],
                f"${sale['total']:.2f}",
                sale_status
            )
            tag = 'returned' if sale_status == 'DEVUELTA' else 'completed'
  
            # Usar el número de ticket como iid para facilitar la búsqueda en show_sale_details
            self.tree.insert("", "end", iid=sale['ticket_number'], values=values, tags=(tag,))
            
        self.tree.tag_configure('returned', foreground='#c0392b') # Rojo para devoluciones
        self.tree.tag_configure('completed', foreground='white') # Blanco para completadas
        
    def show_sale_details(self, event):
        # Obtener el item seleccionado (el iid es el número de ticket)
        if not (selected_item := self.tree.focus()):
            return
        
        try:
            # El iid (identificador interno) es el número de ticket que asignamos en load_sales
            ticket_number = int(selected_item) 
        except ValueError:
            return # No es un ticket válido o es una fila vacía
        
        sales = read_db("sales")
        sale_record = next((s for s in sales if s.get("ticket_number") == ticket_number), None)
        
        if sale_record:
            # El master de SalesHistoryWindow es MenuWindow, cuyo master es MainScreen
            main_screen = self.master.master 
            SaleDetailWindow(self, sale_record, main_screen)
            

    def filter_sales(self):
        start_date = self.date_start_entry.get().strip()
        end_date = self.date_end_entry.get().strip()
        
        if not start_date or not end_date:
   
            messagebox.showwarning("Fechas Requeridas", "Debe ingresar una fecha de inicio y una fecha de fin.")
            return

        self.load_sales('range', start_date, end_date)

# --- NUEVA CLASE: VENTANA DE DETALLES DE VENTA ---
class SaleDetailWindow(ctk.CTkToplevel):
    def __init__(self, master, sale_record, main_screen):
        super().__init__(master)
        # ELIMINADO: self.geometry("450x600")
        self.title(f"Detalles de Venta - Ticket N° {sale_record['ticket_number']}")
        self.transient(master)
        self.grab_set()

        # Obtener el texto formateado del ticket
        ticket_text = main_screen.generate_ticket_text(sale_record)
        
        ctk.CTkLabel(self, text=f"Ticket N°: {sale_record['ticket_number']}", font=ctk.CTkFont(size=18, weight="bold")).pack(pady=(10, 5))
        
        detail_textbox = ctk.CTkTextbox(self, state="normal", font=("Courier", 12))
        detail_textbox.insert("1.0", ticket_text)
        detail_textbox.configure(state="disabled")
        detail_textbox.pack(pady=10, padx=10, fill="both", expand=True)

        ctk.CTkButton(self, text="Cerrar", command=self.destroy).pack(pady=10)
# --------------------------------------------------

class CashCountWindow(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master)
        # ELIMINADO: self.geometry("500x450")
        self.controller = master.master_app
        self.title("Corte de Caja")
        self.transient(master)
        self.grab_set()
        
        ctk.CTkLabel(self, text="Corte de Caja Diario", font=ctk.CTkFont(size=20, weight="bold")).pack(pady=10)
        ctk.CTkLabel(self, text=f"Usuario: {self.controller.current_user}").pack()
        ctk.CTkLabel(self, text=f"Fecha y Hora: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}").pack()
        self.summary_label = ctk.CTkLabel(self, text="--- Calculando... ---", justify="left", font=ctk.CTkFont(family="Courier", size=14))
        self.summary_label.pack(pady=20)
        self.calculate_daily_sales()
        ctk.CTkButton(self, text="Iniciar Corte de Caja y Salir", command=self.perform_cash_count, height=40).pack(pady=10, padx=20, fill="x")
        
    def calculate_daily_sales(self):
      
        sales = read_db("sales")
        today = datetime.date.today()
        daily_sales = [s for s in sales if datetime.datetime.fromisoformat(s['timestamp']).date() == today and s.get("status") == "COMPLETADA"]
        daily_returns = [s for s in sales if datetime.datetime.fromisoformat(s['timestamp']).date() == today and s.get("status") == "DEVUELTA"]
        total_cash = sum(s['total'] for s in daily_sales if s['payment_method'] == 'Efectivo')
        total_card = sum(s['total'] for s in daily_sales if s['payment_method'] == 'Tarjeta Bancaria')
        total_transfer = sum(s['total'] for s in daily_sales if s['payment_method'] == 'Transferencia')
        total_day_gross = sum(s['total'] for s in daily_sales)
        total_returned = sum(r['total'] for r in daily_returns)
        net_total = total_day_gross - total_returned
        summary_text = (f"-- Desglose de Ventas --\n\n"
            f"Ventas en Efectivo:    ${total_cash:10.2f}\n"
            f"Ventas con Tarjeta:    ${total_card:10.2f}\n"
    
            f"Ventas con Transferencia:${total_transfer:10.2f}\n"
            f"----------------------------------\n"
            f"Total Ventas Bruto:    ${total_day_gross:10.2f}\n\n"
            f"Devoluciones del Día:  -${total_returned:10.2f}\n"
            f"==================================\n"
            f"Total Neto en Caja:    ${net_total:10.2f}")
        self.summary_label.configure(text=summary_text)
        
    def perform_cash_count(self):
        if not messagebox.askyesno("Confirmar", "¿Está seguro de realizar el corte? El programa se cerrará.", parent=self): return
        report_content = (f"Fecha: {datetime.date.today()}\n"
            f"Usuario: {self.controller.current_user}\n"
            f"Hora: {datetime.datetime.now().strftime('%H:%M:%S')}\n\n"
            f"{self.summary_label.cget('text')}")
        os.makedirs("cortes", exist_ok=True)
        filename = f"cortes/corte_{datetime.date.today()}.pdf"
        create_pdf_with_logo("Boutique El Impulso", "Corte de Caja", report_content, filename, align='L')
        messagebox.showinfo("Corte Realizado", f"El corte de caja se ha guardado en:\n{filename}\n\nEl programa se cerrará ahora.")
        self.controller.quit()

if __name__ == "__main__":
    setup_database()
    app = POSApp()
    app.mainloop()
